from __future__ import annotations
import nimblephysics_libs._nimblephysics.dynamics
import typing
import nimblephysics_libs._nimblephysics.common
import nimblephysics_libs._nimblephysics.math
import nimblephysics_libs._nimblephysics.neural
import numpy
_Shape = typing.Tuple[int, ...]

__all__ = [
    "ArrowShape",
    "ArrowShapeProperties",
    "AxisOrder",
    "BallJoint",
    "BallJointProperties",
    "BodyNode",
    "BodyNodeAspectProperties",
    "BodyNodeProperties",
    "BodyScaleGroup",
    "BoxShape",
    "CapsuleShape",
    "CollisionAspect",
    "CollisionAspectProperties",
    "CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space",
    "CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space",
    "CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space",
    "CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space",
    "CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space",
    "CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space",
    "CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space",
    "CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint",
    "CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint",
    "CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint",
    "CompositeJoiner_EmbedStateAndProperties_GenericJoint_R4GenericJointStateGenericJointUniqueProperties_Joint",
    "CompositeJoiner_EmbedStateAndProperties_GenericJoint_R6GenericJointStateGenericJointUniqueProperties_Joint",
    "CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint",
    "CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint",
    "ConeShape",
    "ContactEnergyTransmitter",
    "ContactInverseDynamicsResult",
    "CustomJoint1",
    "CustomJoint2",
    "CylinderShape",
    "DataVariance",
    "DegreeOfFreedom",
    "Detachable",
    "DynamicsAspect",
    "DynamicsAspectProperties",
    "EllipsoidShape",
    "EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space",
    "EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space",
    "EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space",
    "EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space",
    "EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space",
    "EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space",
    "EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space",
    "EmbedProperties_EulerJoint_EulerJointUniqueProperties",
    "EmbedProperties_PlanarJoint_PlanarJointUniqueProperties",
    "EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties",
    "EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties",
    "EmbedProperties_ScrewJoint_ScrewJointUniqueProperties",
    "EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties",
    "EmbedProperties_UniversalJoint_UniversalJointUniqueProperties",
    "EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint",
    "EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint",
    "EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint",
    "EmbedStateAndPropertiesOnTopOf_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties_Joint",
    "EmbedStateAndPropertiesOnTopOf_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties_Joint",
    "EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint",
    "EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint",
    "EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties",
    "EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties",
    "EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties",
    "EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties",
    "EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties",
    "EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties",
    "EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties",
    "EnergyAccountingFrame",
    "Entity",
    "EulerFreeJoint",
    "EulerJoint",
    "EulerJointProperties",
    "EulerJointUniqueProperties",
    "Frame",
    "FreeJoint",
    "FreeJointProperties",
    "GenericJointProperties_R1",
    "GenericJointProperties_R2",
    "GenericJointProperties_R3",
    "GenericJointProperties_R4",
    "GenericJointProperties_R6",
    "GenericJointProperties_SE3",
    "GenericJointProperties_SO3",
    "GenericJointUniqueProperties_R1",
    "GenericJointUniqueProperties_R2",
    "GenericJointUniqueProperties_R3",
    "GenericJointUniqueProperties_R4",
    "GenericJointUniqueProperties_R6",
    "GenericJointUniqueProperties_SE3",
    "GenericJointUniqueProperties_SO3",
    "GenericJoint_R1",
    "GenericJoint_R2",
    "GenericJoint_R3",
    "GenericJoint_R4",
    "GenericJoint_R6",
    "GenericJoint_SE3",
    "GenericJoint_SO3",
    "Inertia",
    "JacobianNode",
    "Joint",
    "JointEnergyTransmitter",
    "JointProperties",
    "LineSegmentShape",
    "MeshShape",
    "MetaSkeleton",
    "MultiSphereConvexHullShape",
    "MultipleContactInverseDynamicsOverTimeResult",
    "MultipleContactInverseDynamicsResult",
    "Node",
    "NodeProperties",
    "NodeState",
    "PlanarJoint",
    "PlanarJointProperties",
    "PlanarJointUniqueProperties",
    "PlaneShape",
    "PlaneType",
    "PrismaticJoint",
    "PrismaticJointProperties",
    "PrismaticJointUniqueProperties",
    "ReferentialSkeleton",
    "RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties",
    "RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties",
    "RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties",
    "RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties",
    "RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties",
    "RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties",
    "RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties",
    "RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties",
    "RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties",
    "RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties",
    "RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties",
    "RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties",
    "RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties",
    "RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties",
    "RevoluteJoint",
    "RevoluteJointProperties",
    "RevoluteJointUniqueProperties",
    "ScapulothoracicJoint",
    "ScrewJoint",
    "ScrewJointProperties",
    "ScrewJointUniqueProperties",
    "Shape",
    "ShapeFrame",
    "ShapeFrameProperties",
    "ShapeNode",
    "ShapeNodeProperties",
    "SharedMeshWrapper",
    "SimpleFrame",
    "Skeleton",
    "SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties",
    "SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties",
    "SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties",
    "SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties",
    "SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties",
    "SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties",
    "SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties",
    "SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties",
    "SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties",
    "SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties",
    "SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties",
    "SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties",
    "SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties",
    "SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties",
    "SphereShape",
    "TemplatedJacobianBodyNode",
    "TranslationalJoint",
    "TranslationalJoint2D",
    "TranslationalJoint2DProperties",
    "TranslationalJoint2DUniqueProperties",
    "TranslationalJointProperties",
    "UniversalJoint",
    "UniversalJointProperties",
    "UniversalJointUniqueProperties",
    "VisualAspect",
    "VisualAspectProperties",
    "WeldJoint",
    "WeldJointProperties",
    "ZeroDofJoint",
    "ZeroDofJointProperties"
]


class Shape():
    def addDataVariance(self, variance: int) -> None: ...
    def asMeshShape(self) -> MeshShape: ...
    def checkDataVariance(self, type: DataVariance) -> bool: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def computeInertiaFromDensity(self, density: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def computeInertiaFromMass(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def getBoundingBox(self) -> nimblephysics_libs._nimblephysics.math.BoundingBox: ...
    def getDataVariance(self) -> int: ...
    def getID(self) -> int: ...
    def getType(self) -> str: ...
    def getVolume(self) -> float: ...
    def incrementVersion(self) -> int: ...
    def notifyAlphaUpdated(self, alpha: float) -> None: ...
    def notifyColorUpdated(self, color: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    def refreshData(self) -> None: ...
    def removeDataVariance(self, variance: int) -> None: ...
    def setDataVariance(self, variance: int) -> None: ...
    pass
class ArrowShapeProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, radius: float) -> None: ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float) -> None: ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float) -> None: ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float) -> None: ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float, maxHeadLength: float) -> None: ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float, maxHeadLength: float, s_tArrow: bool) -> None: ...
    @property
    def mHeadLengthScale(self) -> float:
        """
        :type: float
        """
    @mHeadLengthScale.setter
    def mHeadLengthScale(self, arg0: float) -> None:
        pass
    @property
    def mHeadRadiusScale(self) -> float:
        """
        :type: float
        """
    @mHeadRadiusScale.setter
    def mHeadRadiusScale(self, arg0: float) -> None:
        pass
    @property
    def mMaxHeadLength(self) -> float:
        """
        :type: float
        """
    @mMaxHeadLength.setter
    def mMaxHeadLength(self, arg0: float) -> None:
        pass
    @property
    def mMinHeadLength(self) -> float:
        """
        :type: float
        """
    @mMinHeadLength.setter
    def mMinHeadLength(self, arg0: float) -> None:
        pass
    @property
    def mRadius(self) -> float:
        """
        :type: float
        """
    @mRadius.setter
    def mRadius(self, arg0: float) -> None:
        pass
    @property
    def ms_tArrow(self) -> bool:
        """
        :type: bool
        """
    @ms_tArrow.setter
    def ms_tArrow(self, arg0: bool) -> None:
        pass
    pass
class AxisOrder():
    """
    Members:

      XYZ

      XZY

      ZYX

      ZXY
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    XYZ: nimblephysics_libs._nimblephysics.dynamics.AxisOrder # value = <AxisOrder.XYZ: 1>
    XZY: nimblephysics_libs._nimblephysics.dynamics.AxisOrder # value = <AxisOrder.XZY: 3>
    ZXY: nimblephysics_libs._nimblephysics.dynamics.AxisOrder # value = <AxisOrder.ZXY: 2>
    ZYX: nimblephysics_libs._nimblephysics.dynamics.AxisOrder # value = <AxisOrder.ZYX: 0>
    __members__: dict # value = {'XYZ': <AxisOrder.XYZ: 1>, 'XZY': <AxisOrder.XZY: 3>, 'ZYX': <AxisOrder.ZYX: 0>, 'ZXY': <AxisOrder.ZXY: 2>}
    pass
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class BallJointProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, properties: BallJointProperties) -> None: ...
    pass
class Entity():
    def descendsFrom(self, someFrame: Frame) -> bool: ...
    def dirtyAcceleration(self) -> None: ...
    def dirtyTransform(self) -> None: ...
    def dirtyVelocity(self) -> None: ...
    def getName(self) -> str: ...
    def getParentFrame(self) -> Frame: ...
    def isFrame(self) -> bool: ...
    def isQuiet(self) -> bool: ...
    def needsAccelerationUpdate(self) -> bool: ...
    def needsTransformUpdate(self) -> bool: ...
    def needsVelocityUpdate(self) -> bool: ...
    def setName(self, name: str) -> str: ...
    pass
class BodyNodeAspectProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia) -> None: ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia, isCollidable: bool) -> None: ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia, isCollidable: bool, frictionCoeff: float) -> None: ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia, isCollidable: bool, frictionCoeff: float, restitutionCoeff: float) -> None: ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia, isCollidable: bool, frictionCoeff: float, restitutionCoeff: float, gravityMode: bool) -> None: ...
    @property
    def mFrictionCoeff(self) -> float:
        """
        :type: float
        """
    @mFrictionCoeff.setter
    def mFrictionCoeff(self, arg0: float) -> None:
        pass
    @property
    def mGravityMode(self) -> bool:
        """
        :type: bool
        """
    @mGravityMode.setter
    def mGravityMode(self, arg0: bool) -> None:
        pass
    @property
    def mInertia(self) -> Inertia:
        """
        :type: Inertia
        """
    @mInertia.setter
    def mInertia(self, arg0: Inertia) -> None:
        pass
    @property
    def mIsCollidable(self) -> bool:
        """
        :type: bool
        """
    @mIsCollidable.setter
    def mIsCollidable(self, arg0: bool) -> None:
        pass
    @property
    def mName(self) -> str:
        """
        :type: str
        """
    @mName.setter
    def mName(self, arg0: str) -> None:
        pass
    @property
    def mRestitutionCoeff(self) -> float:
        """
        :type: float
        """
    @mRestitutionCoeff.setter
    def mRestitutionCoeff(self, arg0: float) -> None:
        pass
    pass
class BodyNodeProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, aspectProperties: BodyNodeAspectProperties) -> None: ...
    pass
class BodyScaleGroup():
    @property
    def flipAxis(self) -> typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]]:
        """
        :type: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]]
        """
    @flipAxis.setter
    def flipAxis(self, arg0: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]]) -> None:
        pass
    @property
    def nodes(self) -> typing.List[BodyNode]:
        """
        :type: typing.List[BodyNode]
        """
    @nodes.setter
    def nodes(self, arg0: typing.List[BodyNode]) -> None:
        pass
    @property
    def uniformScaling(self) -> bool:
        """
        :type: bool
        """
    @uniformScaling.setter
    def uniformScaling(self, arg0: bool) -> None:
        pass
    pass
class BoxShape(Shape):
    def __init__(self, size: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeInertiaOf(size: numpy.ndarray[numpy.float64, _Shape[3, 1]], mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeVolume(size: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> float: ...
    def getSize(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def setSize(self, size: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class CapsuleShape(Shape):
    def __init__(self, radius: float, height: float) -> None: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeVolumeOf(radius: float, height: float) -> float: ...
    def getHeight(self) -> float: ...
    def getRadius(self) -> float: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def setHeight(self, height: float) -> None: ...
    def setRadius(self, radius: float) -> None: ...
    pass
class CollisionAspect():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, properties: CollisionAspectProperties) -> None: ...
    def getCollidable(self) -> bool: ...
    def isCollidable(self) -> bool: ...
    def setCollidable(self, value: bool) -> None: ...
    pass
class CollisionAspectProperties():
    pass
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties(nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class Joint():
    class ActuatorType():
        """
        Members:

          FORCE

          PASSIVE

          SERVO

          MIMIC

          ACCELERATION

          VELOCITY

          LOCKED
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        ACCELERATION: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.ACCELERATION: 4>
        FORCE: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.FORCE: 0>
        LOCKED: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.LOCKED: 6>
        MIMIC: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.MIMIC: 3>
        PASSIVE: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.PASSIVE: 1>
        SERVO: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.SERVO: 2>
        VELOCITY: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.VELOCITY: 5>
        __members__: dict # value = {'FORCE': <ActuatorType.FORCE: 0>, 'PASSIVE': <ActuatorType.PASSIVE: 1>, 'SERVO': <ActuatorType.SERVO: 2>, 'MIMIC': <ActuatorType.MIMIC: 3>, 'ACCELERATION': <ActuatorType.ACCELERATION: 4>, 'VELOCITY': <ActuatorType.VELOCITY: 5>, 'LOCKED': <ActuatorType.LOCKED: 6>}
        pass
    @typing.overload
    def checkSanity(self) -> bool: ...
    @typing.overload
    def checkSanity(self, printWarnings: bool) -> bool: ...
    def computePotentialEnergy(self) -> float: ...
    def copy(self, otherJoint: Joint) -> None: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getActuatorType(self) -> Joint.ActuatorType: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getChildBodyNode(self) -> BodyNode: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, index: int) -> str: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getJointIndexInSkeleton(self) -> int: ...
    def getJointIndexInTree(self) -> int: ...
    def getName(self) -> str: ...
    def getNearestPositionToDesiredRotation(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 3]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getNumDofs(self) -> int: ...
    def getParentBodyNode(self) -> BodyNode: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativePrimaryAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getRelativeSpatialAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getRelativeSpatialVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getRelativeTransform(self) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSkeleton(self) -> Skeleton: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getTransformFromChildBodyNode(self) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def getTransformFromParentBodyNode(self) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def getTreeIndex(self) -> int: ...
    def getType(self) -> str: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isCyclic(self, index: int) -> bool: ...
    def isDofNamePreserved(self, index: int) -> bool: ...
    def isDynamic(self) -> bool: ...
    def isKinematic(self) -> bool: ...
    def isPositionLimitEnforced(self) -> bool: ...
    def notifyAccelerationUpdated(self) -> None: ...
    def notifyPositionUpdated(self) -> None: ...
    def notifyVelocityUpdated(self) -> None: ...
    def preserveDofName(self, index: int, preserve: bool) -> None: ...
    def removeJointAspect(self) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setActuatorType(self, actuatorType: Joint.ActuatorType) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, coeff: float) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> None: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    @typing.overload
    def setName(self, name: str) -> None: ...
    @typing.overload
    def setName(self, name: str, renameDofs: bool) -> None: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLimitEnforced(self, isPositionLimitEnforced: bool) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setProperties(self, properties: JointProperties) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setTransformFromChildBodyNode(self, T: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    def setTransformFromParentBodyNode(self, T: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    ACCELERATION: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.ACCELERATION: 4>
    DefaultActuatorType: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.FORCE: 0>
    FORCE: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.FORCE: 0>
    LOCKED: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.LOCKED: 6>
    PASSIVE: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.PASSIVE: 1>
    SERVO: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.SERVO: 2>
    VELOCITY: nimblephysics_libs._nimblephysics.dynamics.Joint.ActuatorType # value = <ActuatorType.VELOCITY: 5>
    pass
class ConeShape(Shape):
    def __init__(self, radius: float, height: float) -> None: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeVolume(radius: float, height: float) -> float: ...
    def getHeight(self) -> float: ...
    def getRadius(self) -> float: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def setHeight(self, height: float) -> None: ...
    def setRadius(self, radius: float) -> None: ...
    pass
class ContactEnergyTransmitter():
    def __init__(self) -> None: ...
    @property
    def contactBody(self) -> str:
        """
        :type: str
        """
    @contactBody.setter
    def contactBody(self, arg0: str) -> None:
        pass
    @property
    def contactBodyCenter(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @contactBodyCenter.setter
    def contactBodyCenter(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def powerToBody(self) -> float:
        """
        :type: float
        """
    @powerToBody.setter
    def powerToBody(self, arg0: float) -> None:
        pass
    @property
    def worldCenter(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @worldCenter.setter
    def worldCenter(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def worldForce(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @worldForce.setter
    def worldForce(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def worldMoment(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @worldMoment.setter
    def worldMoment(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    pass
class ContactInverseDynamicsResult():
    def __init__(self) -> None: ...
    def sumError(self) -> float: ...
    @property
    def acc(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @acc.setter
    def acc(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def contactBody(self) -> BodyNode:
        """
        :type: BodyNode
        """
    @contactBody.setter
    def contactBody(self, arg0: BodyNode) -> None:
        pass
    @property
    def contactWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @contactWrench.setter
    def contactWrench(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def jointTorques(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @jointTorques.setter
    def jointTorques(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def pos(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @pos.setter
    def pos(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def skel(self) -> Skeleton:
        """
        :type: Skeleton
        """
    @skel.setter
    def skel(self, arg0: Skeleton) -> None:
        pass
    @property
    def vel(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @vel.setter
    def vel(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    pass
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class CylinderShape(Shape):
    def __init__(self, radius: float, height: float) -> None: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeVolumeOf(radius: float, height: float) -> float: ...
    def getHeight(self) -> float: ...
    def getRadius(self) -> float: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def setHeight(self, height: float) -> None: ...
    def setRadius(self, radius: float) -> None: ...
    pass
class DataVariance():
    """
    Members:

      STATIC

      DYNAMIC_PRIMITIVE

      DYNAMIC_COLOR

      DYNAMIC_VERTICES

      DYNAMIC_ELEMENTS

      DYNAMIC

      DYNAMIC_TRANSFORM
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    DYNAMIC: nimblephysics_libs._nimblephysics.dynamics.DataVariance # value = <DataVariance.DYNAMIC: 255>
    DYNAMIC_COLOR: nimblephysics_libs._nimblephysics.dynamics.DataVariance # value = <DataVariance.DYNAMIC_COLOR: 8>
    DYNAMIC_ELEMENTS: nimblephysics_libs._nimblephysics.dynamics.DataVariance # value = <DataVariance.DYNAMIC_ELEMENTS: 32>
    DYNAMIC_PRIMITIVE: nimblephysics_libs._nimblephysics.dynamics.DataVariance # value = <DataVariance.DYNAMIC_PRIMITIVE: 4>
    DYNAMIC_TRANSFORM: nimblephysics_libs._nimblephysics.dynamics.DataVariance # value = <DataVariance.DYNAMIC_TRANSFORM: 2>
    DYNAMIC_VERTICES: nimblephysics_libs._nimblephysics.dynamics.DataVariance # value = <DataVariance.DYNAMIC_VERTICES: 16>
    STATIC: nimblephysics_libs._nimblephysics.dynamics.DataVariance # value = <DataVariance.STATIC: 0>
    __members__: dict # value = {'STATIC': <DataVariance.STATIC: 0>, 'DYNAMIC_PRIMITIVE': <DataVariance.DYNAMIC_PRIMITIVE: 4>, 'DYNAMIC_COLOR': <DataVariance.DYNAMIC_COLOR: 8>, 'DYNAMIC_VERTICES': <DataVariance.DYNAMIC_VERTICES: 16>, 'DYNAMIC_ELEMENTS': <DataVariance.DYNAMIC_ELEMENTS: 32>, 'DYNAMIC': <DataVariance.DYNAMIC: 255>, 'DYNAMIC_TRANSFORM': <DataVariance.DYNAMIC_TRANSFORM: 2>}
    pass
class DegreeOfFreedom():
    def getAcceleration(self) -> float: ...
    def getAccelerationLimits(self) -> typing.Tuple[float, float]: ...
    def getAccelerationLowerLimit(self) -> float: ...
    def getAccelerationUpperLimit(self) -> float: ...
    def getCommand(self) -> float: ...
    def getConstraintImpulse(self) -> float: ...
    def getControlForce(self) -> float: ...
    def getControlForceLimits(self) -> typing.Tuple[float, float]: ...
    def getControlForceLowerLimit(self) -> float: ...
    def getControlForceUpperLimit(self) -> float: ...
    def getCoulombFriction(self) -> float: ...
    def getDampingCoefficient(self) -> float: ...
    def getIndexInJoint(self) -> int: ...
    def getIndexInSkeleton(self) -> int: ...
    def getIndexInTree(self) -> int: ...
    def getInitialPosition(self) -> float: ...
    def getInitialVelocity(self) -> float: ...
    def getJointName(self) -> str: ...
    def getName(self) -> str: ...
    def getPosition(self) -> float: ...
    def getPositionLimits(self) -> typing.Tuple[float, float]: ...
    def getPositionLowerLimit(self) -> float: ...
    def getPositionUpperLimit(self) -> float: ...
    def getRestPosition(self) -> float: ...
    def getSkeleton(self) -> Skeleton: ...
    def getSpringStiffness(self) -> float: ...
    def getTreeIndex(self) -> int: ...
    def getVelocity(self) -> float: ...
    def getVelocityChange(self) -> float: ...
    def getVelocityLimits(self) -> typing.Tuple[float, float]: ...
    def getVelocityLowerLimit(self) -> float: ...
    def getVelocityUpperLimit(self) -> float: ...
    def hasPositionLimit(self) -> bool: ...
    def isCyclic(self) -> bool: ...
    def isNamePreserved(self) -> bool: ...
    def preserveName(self, preserve: bool) -> None: ...
    def resetAcceleration(self) -> None: ...
    def resetCommand(self) -> None: ...
    def resetConstraintImpulse(self) -> None: ...
    def resetControlForce(self) -> None: ...
    def resetPosition(self) -> None: ...
    def resetVelocity(self) -> None: ...
    def resetVelocityChange(self) -> None: ...
    def setAcceleration(self, acceleration: float) -> None: ...
    @typing.overload
    def setAccelerationLimits(self, lowerLimit: float, upperLimit: float) -> None: ...
    @typing.overload
    def setAccelerationLimits(self, limits: typing.Tuple[float, float]) -> None: ...
    def setAccelerationLowerLimit(self, limit: float) -> None: ...
    def setAccelerationUpperLimit(self, limit: float) -> None: ...
    def setCommand(self, command: float) -> None: ...
    def setConstraintImpulse(self, impulse: float) -> None: ...
    def setControlForce(self, force: float) -> None: ...
    @typing.overload
    def setControlForceLimits(self, lowerLimit: float, upperLimit: float) -> None: ...
    @typing.overload
    def setControlForceLimits(self, limits: typing.Tuple[float, float]) -> None: ...
    def setControlForceLowerLimit(self, limit: float) -> None: ...
    def setControlForceUpperLimit(self, limit: float) -> None: ...
    def setCoulombFriction(self, friction: float) -> None: ...
    def setDampingCoefficient(self, coeff: float) -> None: ...
    def setInitialPosition(self, initial: float) -> None: ...
    def setInitialVelocity(self, initial: float) -> None: ...
    @typing.overload
    def setName(self, name: str) -> str: ...
    @typing.overload
    def setName(self, name: str, preserveName: bool) -> str: ...
    def setPosition(self, position: float) -> None: ...
    @typing.overload
    def setPositionLimits(self, lowerLimit: float, upperLimit: float) -> None: ...
    @typing.overload
    def setPositionLimits(self, limits: typing.Tuple[float, float]) -> None: ...
    def setPositionLowerLimit(self, limit: float) -> None: ...
    def setPositionUpperLimit(self, limit: float) -> None: ...
    def setRestPosition(self, q0: float) -> None: ...
    def setSpringStiffness(self, k: float) -> None: ...
    def setVelocity(self, velocity: float) -> None: ...
    def setVelocityChange(self, velocityChange: float) -> None: ...
    @typing.overload
    def setVelocityLimits(self, lowerLimit: float, upperLimit: float) -> None: ...
    @typing.overload
    def setVelocityLimits(self, limits: typing.Tuple[float, float]) -> None: ...
    def setVelocityLowerLimit(self, limit: float) -> None: ...
    def setVelocityUpperLimit(self, limit: float) -> None: ...
    pass
class Detachable(Entity):
    def setParentFrame(self, newParentFrame: Frame) -> None: ...
    pass
class DynamicsAspect():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, properties: DynamicsAspectProperties) -> None: ...
    def getFrictionCoeff(self) -> float: ...
    def getRestitutionCoeff(self) -> float: ...
    def setFrictionCoeff(self, value: float) -> None: ...
    def setRestitutionCoeff(self, value: float) -> None: ...
    pass
class DynamicsAspectProperties():
    pass
class EllipsoidShape(Shape):
    def __init__(self, diameters: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeInertiaOf(diameters: numpy.ndarray[numpy.float64, _Shape[3, 1]], mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeVolumeOf(diameters: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> float: ...
    def getDiameters(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRadii(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isSphere(self) -> bool: ...
    def setDiameters(self, diameters: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setRadii(self, radii: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class GenericJoint_R1(EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def computePotentialEnergy(self) -> float: ...
    def copy(self, otherJoint: GenericJoint_R1) -> None: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, index: int) -> str: ...
    def getGenericJointProperties(self) -> GenericJointProperties_R1: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getNumDofs(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[1, 1]], q1: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isDofNamePreserved(self, index: int) -> bool: ...
    def preserveDofName(self, index: int, preserve: bool) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, d: float) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str: ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R1) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R1) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    NumDofs = 1
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    def __init__(self) -> None: ...
    pass
class EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EnergyAccountingFrame():
    def __init__(self) -> None: ...
    @property
    def bodyCenters(self) -> typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]]:
        """
        :type: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]]
        """
    @bodyCenters.setter
    def bodyCenters(self, arg0: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]]) -> None:
        pass
    @property
    def bodyChildJointPowerSum(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @bodyChildJointPowerSum.setter
    def bodyChildJointPowerSum(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def bodyChildJointPowers(self) -> typing.List[typing.List[float]]:
        """
        :type: typing.List[typing.List[float]]
        """
    @bodyChildJointPowers.setter
    def bodyChildJointPowers(self, arg0: typing.List[typing.List[float]]) -> None:
        pass
    @property
    def bodyExternalForcePower(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @bodyExternalForcePower.setter
    def bodyExternalForcePower(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def bodyGravityPower(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @bodyGravityPower.setter
    def bodyGravityPower(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def bodyKineticEnergy(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @bodyKineticEnergy.setter
    def bodyKineticEnergy(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def bodyKineticEnergyDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @bodyKineticEnergyDeriv.setter
    def bodyKineticEnergyDeriv(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def bodyParentJointPower(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @bodyParentJointPower.setter
    def bodyParentJointPower(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def bodyPotentialEnergy(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @bodyPotentialEnergy.setter
    def bodyPotentialEnergy(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def bodyPotentialEnergyDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @bodyPotentialEnergyDeriv.setter
    def bodyPotentialEnergyDeriv(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def contacts(self) -> typing.List[ContactEnergyTransmitter]:
        """
        :type: typing.List[ContactEnergyTransmitter]
        """
    @contacts.setter
    def contacts(self, arg0: typing.List[ContactEnergyTransmitter]) -> None:
        pass
    @property
    def joints(self) -> typing.List[JointEnergyTransmitter]:
        """
        :type: typing.List[JointEnergyTransmitter]
        """
    @joints.setter
    def joints(self, arg0: typing.List[JointEnergyTransmitter]) -> None:
        pass
    pass
class Frame(Entity):
    @staticmethod
    def World() -> Frame: ...
    def dirtyAcceleration(self) -> None: ...
    def dirtyTransform(self) -> None: ...
    def dirtyVelocity(self) -> None: ...
    @typing.overload
    def getAngularAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getAngularAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getAngularAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getAngularVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getAngularVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getAngularVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getChildEntities(self) -> typing.Set[Entity]: ...
    def getChildFrames(self) -> typing.Set[Frame]: ...
    @typing.overload
    def getLinearAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getNumChildEntities(self) -> int: ...
    def getNumChildFrames(self) -> int: ...
    def getRelativeTransform(self) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    @typing.overload
    def getSpatialAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getSpatialAcceleration(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getSpatialAcceleration(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getSpatialVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getSpatialVelocity(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getSpatialVelocity(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getTransform(self) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    @typing.overload
    def getTransform(self, withRespectTo: Frame) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    @typing.overload
    def getTransform(self, withRespectTo: Frame, inCoordinatesOf: Frame) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def getWorldTransform(self) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def isShapeFrame(self) -> bool: ...
    def isWorld(self) -> bool: ...
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R6GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EmbedProperties_EulerJoint_EulerJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EulerJointUniqueProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, axisOrder: AxisOrder) -> None: ...
    pass
class EulerJointProperties(EulerJointUniqueProperties):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: EulerJointProperties) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: EulerJointProperties, uniqueProperties: EulerJointUniqueProperties) -> None: ...
    @property
    def mAxisOrder(self) -> AxisOrder:
        """
        :type: AxisOrder
        """
    @mAxisOrder.setter
    def mAxisOrder(self, arg0: AxisOrder) -> None:
        pass
    pass
class JacobianNode(Frame, Entity):
    def dependsOn(self, genCoordIndex: int) -> bool: ...
    def dirtyJacobian(self) -> None: ...
    def dirtyJacobianDeriv(self) -> None: ...
    @typing.overload
    def getAngularJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    def getDependentGenCoordIndex(self, arrayIndex: int) -> int: ...
    @typing.overload
    def getJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getLinearJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    def getNumDependentDofs(self) -> int: ...
    def getNumDependentGenCoords(self) -> int: ...
    def getWorldJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class FreeJointProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, properties: FreeJointProperties) -> None: ...
    pass
class GenericJointUniqueProperties_R1():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[1, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[1, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[1, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[1, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[1, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[1, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[1, 1]], coulombFrictions: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None: ...
    @property
    def mAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mAccelerationLowerLimits.setter
    def mAccelerationLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mAccelerationUpperLimits.setter
    def mAccelerationUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mDampingCoefficients(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mDampingCoefficients.setter
    def mDampingCoefficients(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mDofNames(self) -> typing.List[str[1]]:
        """
        :type: typing.List[str[1]]
        """
    @mDofNames.setter
    def mDofNames(self, arg0: typing.List[str[1]]) -> None:
        pass
    @property
    def mForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mForceLowerLimits.setter
    def mForceLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mForceUpperLimits.setter
    def mForceUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mFrictions(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mFrictions.setter
    def mFrictions(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mInitialPositions.setter
    def mInitialPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mInitialVelocities.setter
    def mInitialVelocities(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mPositionLowerLimits.setter
    def mPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mPositionUpperLimits.setter
    def mPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mPreserveDofNames(self) -> typing.List[bool[1]]:
        """
        :type: typing.List[bool[1]]
        """
    @mPreserveDofNames.setter
    def mPreserveDofNames(self, arg0: typing.List[bool[1]]) -> None:
        pass
    @property
    def mRestPositions(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mRestPositions.setter
    def mRestPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mSpringStiffnesses(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mSpringStiffnesses.setter
    def mSpringStiffnesses(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mVelocityLowerLimits.setter
    def mVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    @property
    def mVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[1, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[1, 1]]
        """
    @mVelocityUpperLimits.setter
    def mVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> None:
        pass
    pass
class GenericJointUniqueProperties_R2():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[2, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[2, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[2, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[2, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[2, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[2, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[2, 1]], coulombFrictions: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @property
    def mAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mAccelerationLowerLimits.setter
    def mAccelerationLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mAccelerationUpperLimits.setter
    def mAccelerationUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mDampingCoefficients(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mDampingCoefficients.setter
    def mDampingCoefficients(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mDofNames(self) -> typing.List[str[2]]:
        """
        :type: typing.List[str[2]]
        """
    @mDofNames.setter
    def mDofNames(self, arg0: typing.List[str[2]]) -> None:
        pass
    @property
    def mForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mForceLowerLimits.setter
    def mForceLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mForceUpperLimits.setter
    def mForceUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mFrictions(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mFrictions.setter
    def mFrictions(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mInitialPositions.setter
    def mInitialPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mInitialVelocities.setter
    def mInitialVelocities(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mPositionLowerLimits.setter
    def mPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mPositionUpperLimits.setter
    def mPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mPreserveDofNames(self) -> typing.List[bool[2]]:
        """
        :type: typing.List[bool[2]]
        """
    @mPreserveDofNames.setter
    def mPreserveDofNames(self, arg0: typing.List[bool[2]]) -> None:
        pass
    @property
    def mRestPositions(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mRestPositions.setter
    def mRestPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mSpringStiffnesses(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mSpringStiffnesses.setter
    def mSpringStiffnesses(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mVelocityLowerLimits.setter
    def mVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    @property
    def mVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[2, 1]]
        """
    @mVelocityUpperLimits.setter
    def mVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None:
        pass
    pass
class GenericJointUniqueProperties_R3():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[3, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[3, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[3, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[3, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[3, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[3, 1]], coulombFrictions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @property
    def mAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mAccelerationLowerLimits.setter
    def mAccelerationLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mAccelerationUpperLimits.setter
    def mAccelerationUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mDampingCoefficients(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mDampingCoefficients.setter
    def mDampingCoefficients(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mDofNames(self) -> typing.List[str[3]]:
        """
        :type: typing.List[str[3]]
        """
    @mDofNames.setter
    def mDofNames(self, arg0: typing.List[str[3]]) -> None:
        pass
    @property
    def mForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mForceLowerLimits.setter
    def mForceLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mForceUpperLimits.setter
    def mForceUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mFrictions(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mFrictions.setter
    def mFrictions(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mInitialPositions.setter
    def mInitialPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mInitialVelocities.setter
    def mInitialVelocities(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mPositionLowerLimits.setter
    def mPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mPositionUpperLimits.setter
    def mPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mPreserveDofNames(self) -> typing.List[bool[3]]:
        """
        :type: typing.List[bool[3]]
        """
    @mPreserveDofNames.setter
    def mPreserveDofNames(self, arg0: typing.List[bool[3]]) -> None:
        pass
    @property
    def mRestPositions(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mRestPositions.setter
    def mRestPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mSpringStiffnesses(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mSpringStiffnesses.setter
    def mSpringStiffnesses(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mVelocityLowerLimits.setter
    def mVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mVelocityUpperLimits.setter
    def mVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    pass
class GenericJointUniqueProperties_R4():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[4, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[4, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[4, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[4, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[4, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[4, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[4, 1]], coulombFrictions: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @property
    def mAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mAccelerationLowerLimits.setter
    def mAccelerationLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mAccelerationUpperLimits.setter
    def mAccelerationUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mDampingCoefficients(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mDampingCoefficients.setter
    def mDampingCoefficients(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mDofNames(self) -> typing.List[str[4]]:
        """
        :type: typing.List[str[4]]
        """
    @mDofNames.setter
    def mDofNames(self, arg0: typing.List[str[4]]) -> None:
        pass
    @property
    def mForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mForceLowerLimits.setter
    def mForceLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mForceUpperLimits.setter
    def mForceUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mFrictions(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mFrictions.setter
    def mFrictions(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mInitialPositions.setter
    def mInitialPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mInitialVelocities.setter
    def mInitialVelocities(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mPositionLowerLimits.setter
    def mPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mPositionUpperLimits.setter
    def mPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mPreserveDofNames(self) -> typing.List[bool[4]]:
        """
        :type: typing.List[bool[4]]
        """
    @mPreserveDofNames.setter
    def mPreserveDofNames(self, arg0: typing.List[bool[4]]) -> None:
        pass
    @property
    def mRestPositions(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mRestPositions.setter
    def mRestPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mSpringStiffnesses(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mSpringStiffnesses.setter
    def mSpringStiffnesses(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mVelocityLowerLimits.setter
    def mVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    @property
    def mVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[4, 1]]
        """
    @mVelocityUpperLimits.setter
    def mVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None:
        pass
    pass
class GenericJointUniqueProperties_R6():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[6, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[6, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[6, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[6, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[6, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[6, 1]], coulombFrictions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @property
    def mAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mAccelerationLowerLimits.setter
    def mAccelerationLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mAccelerationUpperLimits.setter
    def mAccelerationUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mDampingCoefficients(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mDampingCoefficients.setter
    def mDampingCoefficients(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mDofNames(self) -> typing.List[str[6]]:
        """
        :type: typing.List[str[6]]
        """
    @mDofNames.setter
    def mDofNames(self, arg0: typing.List[str[6]]) -> None:
        pass
    @property
    def mForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mForceLowerLimits.setter
    def mForceLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mForceUpperLimits.setter
    def mForceUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mFrictions(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mFrictions.setter
    def mFrictions(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mInitialPositions.setter
    def mInitialPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mInitialVelocities.setter
    def mInitialVelocities(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mPositionLowerLimits.setter
    def mPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mPositionUpperLimits.setter
    def mPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mPreserveDofNames(self) -> typing.List[bool[6]]:
        """
        :type: typing.List[bool[6]]
        """
    @mPreserveDofNames.setter
    def mPreserveDofNames(self, arg0: typing.List[bool[6]]) -> None:
        pass
    @property
    def mRestPositions(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mRestPositions.setter
    def mRestPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mSpringStiffnesses(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mSpringStiffnesses.setter
    def mSpringStiffnesses(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mVelocityLowerLimits.setter
    def mVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mVelocityUpperLimits.setter
    def mVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    pass
class GenericJointUniqueProperties_SE3():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[6, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[6, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[6, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[6, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[6, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[6, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[6, 1]], coulombFrictions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @property
    def mAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mAccelerationLowerLimits.setter
    def mAccelerationLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mAccelerationUpperLimits.setter
    def mAccelerationUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mDampingCoefficients(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mDampingCoefficients.setter
    def mDampingCoefficients(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mDofNames(self) -> typing.List[str[6]]:
        """
        :type: typing.List[str[6]]
        """
    @mDofNames.setter
    def mDofNames(self, arg0: typing.List[str[6]]) -> None:
        pass
    @property
    def mForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mForceLowerLimits.setter
    def mForceLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mForceUpperLimits.setter
    def mForceUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mFrictions(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mFrictions.setter
    def mFrictions(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mInitialPositions.setter
    def mInitialPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mInitialVelocities.setter
    def mInitialVelocities(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mPositionLowerLimits.setter
    def mPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mPositionUpperLimits.setter
    def mPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mPreserveDofNames(self) -> typing.List[bool[6]]:
        """
        :type: typing.List[bool[6]]
        """
    @mPreserveDofNames.setter
    def mPreserveDofNames(self, arg0: typing.List[bool[6]]) -> None:
        pass
    @property
    def mRestPositions(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mRestPositions.setter
    def mRestPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mSpringStiffnesses(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mSpringStiffnesses.setter
    def mSpringStiffnesses(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mVelocityLowerLimits.setter
    def mVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    @property
    def mVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[6, 1]]
        """
    @mVelocityUpperLimits.setter
    def mVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None:
        pass
    pass
class GenericJointUniqueProperties_SO3():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[3, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[3, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[3, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialPositions: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], initialVelocities: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64, _Shape[3, 1]], springStiffness: numpy.ndarray[numpy.float64, _Shape[3, 1]], restPosition: numpy.ndarray[numpy.float64, _Shape[3, 1]], dampingCoefficient: numpy.ndarray[numpy.float64, _Shape[3, 1]], coulombFrictions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @property
    def mAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mAccelerationLowerLimits.setter
    def mAccelerationLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mAccelerationUpperLimits.setter
    def mAccelerationUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mDampingCoefficients(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mDampingCoefficients.setter
    def mDampingCoefficients(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mDofNames(self) -> typing.List[str[3]]:
        """
        :type: typing.List[str[3]]
        """
    @mDofNames.setter
    def mDofNames(self, arg0: typing.List[str[3]]) -> None:
        pass
    @property
    def mForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mForceLowerLimits.setter
    def mForceLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mForceUpperLimits.setter
    def mForceUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mFrictions(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mFrictions.setter
    def mFrictions(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mInitialPositions.setter
    def mInitialPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mInitialVelocities.setter
    def mInitialVelocities(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mPositionLowerLimits.setter
    def mPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mPositionUpperLimits.setter
    def mPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mPreserveDofNames(self) -> typing.List[bool[3]]:
        """
        :type: typing.List[bool[3]]
        """
    @mPreserveDofNames.setter
    def mPreserveDofNames(self, arg0: typing.List[bool[3]]) -> None:
        pass
    @property
    def mRestPositions(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mRestPositions.setter
    def mRestPositions(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mSpringStiffnesses(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mSpringStiffnesses.setter
    def mSpringStiffnesses(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mVelocityLowerLimits.setter
    def mVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mVelocityUpperLimits.setter
    def mVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    pass
class JointProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @property
    def mActuatorType(self) -> Joint.ActuatorType:
        """
        :type: Joint.ActuatorType
        """
    @mActuatorType.setter
    def mActuatorType(self, arg0: Joint.ActuatorType) -> None:
        pass
    @property
    def mIsPositionLimitEnforced(self) -> bool:
        """
        :type: bool
        """
    @mIsPositionLimitEnforced.setter
    def mIsPositionLimitEnforced(self, arg0: bool) -> None:
        pass
    @property
    def mMimicJoint(self) -> Joint:
        """
        :type: Joint
        """
    @mMimicJoint.setter
    def mMimicJoint(self, arg0: Joint) -> None:
        pass
    @property
    def mMimicMultiplier(self) -> float:
        """
        :type: float
        """
    @mMimicMultiplier.setter
    def mMimicMultiplier(self, arg0: float) -> None:
        pass
    @property
    def mMimicOffset(self) -> float:
        """
        :type: float
        """
    @mMimicOffset.setter
    def mMimicOffset(self, arg0: float) -> None:
        pass
    @property
    def mName(self) -> str:
        """
        :type: str
        """
    @mName.setter
    def mName(self, arg0: str) -> None:
        pass
    @property
    def mT_ChildBodyToJoint(self) -> nimblephysics_libs._nimblephysics.math.Isometry3:
        """
        :type: nimblephysics_libs._nimblephysics.math.Isometry3
        """
    @mT_ChildBodyToJoint.setter
    def mT_ChildBodyToJoint(self, arg0: nimblephysics_libs._nimblephysics.math.Isometry3) -> None:
        pass
    @property
    def mT_ParentBodyToJoint(self) -> nimblephysics_libs._nimblephysics.math.Isometry3:
        """
        :type: nimblephysics_libs._nimblephysics.math.Isometry3
        """
    @mT_ParentBodyToJoint.setter
    def mT_ParentBodyToJoint(self, arg0: nimblephysics_libs._nimblephysics.math.Isometry3) -> None:
        pass
    pass
class GenericJointProperties_R2(JointProperties, GenericJointUniqueProperties_R2):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R2) -> None: ...
    pass
class GenericJointProperties_R3(JointProperties, GenericJointUniqueProperties_R3):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R3) -> None: ...
    pass
class GenericJointProperties_R4(JointProperties, GenericJointUniqueProperties_R4):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R4) -> None: ...
    pass
class GenericJointProperties_R6(JointProperties, GenericJointUniqueProperties_R6):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R6) -> None: ...
    pass
class GenericJointProperties_SE3(JointProperties, GenericJointUniqueProperties_SE3):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_SE3) -> None: ...
    pass
class GenericJointProperties_SO3(JointProperties, GenericJointUniqueProperties_SO3):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_SO3) -> None: ...
    pass
class EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class EmbedProperties_UniversalJoint_UniversalJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class GenericJoint_R3(EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def computePotentialEnergy(self) -> float: ...
    def copy(self, otherJoint: GenericJoint_R3) -> None: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, index: int) -> str: ...
    def getGenericJointProperties(self) -> GenericJointProperties_R3: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getNumDofs(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[3, 1]], q1: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 3]]: ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isDofNamePreserved(self, index: int) -> bool: ...
    def preserveDofName(self, index: int, preserve: bool) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, d: float) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str: ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R3) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R3) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    NumDofs = 3
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R4GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R6GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class Inertia():
    @typing.overload
    def __init__(self, inertiaMatrix: numpy.ndarray[numpy.float64, _Shape[6, 6]]) -> None: ...
    @typing.overload
    def __init__(self, mass: float, centerOfMass: numpy.ndarray[numpy.float64, _Shape[3, 1]], momentOfInertia: numpy.ndarray[numpy.float64, _Shape[3, 3]]) -> None: ...
    pass
class TemplatedJacobianBodyNode(JacobianNode, Frame, Entity):
    @typing.overload
    def getAngularJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getLinearJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    def getWorldJacobian(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class JointEnergyTransmitter():
    def __init__(self) -> None: ...
    @property
    def childBody(self) -> str:
        """
        :type: str
        """
    @childBody.setter
    def childBody(self, arg0: str) -> None:
        pass
    @property
    def childCenter(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @childCenter.setter
    def childCenter(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @name.setter
    def name(self, arg0: str) -> None:
        pass
    @property
    def parentBody(self) -> str:
        """
        :type: str
        """
    @parentBody.setter
    def parentBody(self, arg0: str) -> None:
        pass
    @property
    def parentCenter(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @parentCenter.setter
    def parentCenter(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def powerToChild(self) -> float:
        """
        :type: float
        """
    @powerToChild.setter
    def powerToChild(self, arg0: float) -> None:
        pass
    @property
    def powerToParent(self) -> float:
        """
        :type: float
        """
    @powerToParent.setter
    def powerToParent(self, arg0: float) -> None:
        pass
    @property
    def worldCenter(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @worldCenter.setter
    def worldCenter(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    pass
class GenericJointProperties_R1(JointProperties, GenericJointUniqueProperties_R1):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None: ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R1) -> None: ...
    pass
class LineSegmentShape(Shape):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, thickness: float) -> None: ...
    @typing.overload
    def __init__(self, v1: numpy.ndarray[numpy.float64, _Shape[3, 1]], v2: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, v1: numpy.ndarray[numpy.float64, _Shape[3, 1]], v2: numpy.ndarray[numpy.float64, _Shape[3, 1]], thickness: float) -> None: ...
    def addConnection(self, idx1: int, idx2: int) -> None: ...
    @typing.overload
    def addVertex(self, v: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> int: ...
    @typing.overload
    def addVertex(self, v: numpy.ndarray[numpy.float64, _Shape[3, 1]], parent: int) -> int: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getThickness(self) -> float: ...
    def getType(self) -> str: ...
    def getVertex(self, idx: int) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def removeConnection(self, vertexIdx1: int, vertexIdx2: int) -> None: ...
    @typing.overload
    def removeConnection(self, connectionIdx: int) -> None: ...
    def removeVertex(self, idx: int) -> None: ...
    def setThickness(self, thickness: float) -> None: ...
    def setVertex(self, idx: int, v: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class MeshShape(Shape):
    class ColorMode():
        """
        Members:

          MATERIAL_COLOR

          COLOR_INDEX

          SHAPE_COLOR
        """
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, value: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str:
            """
            :type: str
            """
        @property
        def value(self) -> int:
            """
            :type: int
            """
        COLOR_INDEX: nimblephysics_libs._nimblephysics.dynamics.MeshShape.ColorMode # value = <ColorMode.COLOR_INDEX: 1>
        MATERIAL_COLOR: nimblephysics_libs._nimblephysics.dynamics.MeshShape.ColorMode # value = <ColorMode.MATERIAL_COLOR: 0>
        SHAPE_COLOR: nimblephysics_libs._nimblephysics.dynamics.MeshShape.ColorMode # value = <ColorMode.SHAPE_COLOR: 2>
        __members__: dict # value = {'MATERIAL_COLOR': <ColorMode.MATERIAL_COLOR: 0>, 'COLOR_INDEX': <ColorMode.COLOR_INDEX: 1>, 'SHAPE_COLOR': <ColorMode.SHAPE_COLOR: 2>}
        pass
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]], mesh: SharedMeshWrapper) -> None: ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]], mesh: SharedMeshWrapper, uri: nimblephysics_libs._nimblephysics.common.Uri) -> None: ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]], mesh: SharedMeshWrapper, uri: nimblephysics_libs._nimblephysics.common.Uri, resourceRetriever: nimblephysics_libs._nimblephysics.common.ResourceRetriever) -> None: ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]], path: str) -> None: ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]], path: str, resourceRetriever: nimblephysics_libs._nimblephysics.common.ResourceRetriever) -> None: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def getDisplayList(self) -> int: ...
    def getMeshPath(self) -> str: ...
    def getMeshUri(self) -> str: ...
    def getMeshUri2(self) -> nimblephysics_libs._nimblephysics.common.Uri: ...
    def getResourceRetriever(self) -> nimblephysics_libs._nimblephysics.common.ResourceRetriever: ...
    def getScale(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def notifyAlphaUpdated(self, alpha: float) -> None: ...
    def setDisplayList(self, index: int) -> None: ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper) -> None: ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper, path: str) -> None: ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper, path: str, resourceRetriever: nimblephysics_libs._nimblephysics.common.ResourceRetriever) -> None: ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper, path: nimblephysics_libs._nimblephysics.common.Uri) -> None: ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper, path: nimblephysics_libs._nimblephysics.common.Uri, resourceRetriever: nimblephysics_libs._nimblephysics.common.ResourceRetriever) -> None: ...
    def setScale(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def update(self) -> None: ...
    COLOR_INDEX: nimblephysics_libs._nimblephysics.dynamics.MeshShape.ColorMode # value = <ColorMode.COLOR_INDEX: 1>
    MATERIAL_COLOR: nimblephysics_libs._nimblephysics.dynamics.MeshShape.ColorMode # value = <ColorMode.MATERIAL_COLOR: 0>
    SHAPE_COLOR: nimblephysics_libs._nimblephysics.dynamics.MeshShape.ColorMode # value = <ColorMode.SHAPE_COLOR: 2>
    pass
class MetaSkeleton():
    def clearExternalForces(self) -> None: ...
    def clearInternalForces(self) -> None: ...
    @typing.overload
    def cloneMetaSkeleton(self, cloneName: str) -> MetaSkeleton: ...
    @typing.overload
    def cloneMetaSkeleton(self) -> MetaSkeleton: ...
    def computeKineticEnergy(self) -> float: ...
    def computeLagrangian(self) -> float: ...
    def computePotentialEnergy(self) -> float: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    @typing.overload
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getAccelerationLowerLimits(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    @typing.overload
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getAccelerationUpperLimits(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getAccelerations(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, relativeTo: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    def getAugMassMatrix(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    @typing.overload
    def getBodyNode(self, index: int) -> BodyNode: ...
    @typing.overload
    def getBodyNode(self, treeIndex: str) -> BodyNode: ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    @typing.overload
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getCommands(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    @typing.overload
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getControlForceLowerLimits(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    @typing.overload
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getControlForceUpperLimits(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getControlForces(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoriolisAndGravityForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoriolisForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getDof(self, index: int) -> DegreeOfFreedom: ...
    def getDofs(self) -> typing.List[DegreeOfFreedom]: ...
    def getExternalForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGravityForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int: ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int: ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int: ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int: ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int: ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int: ...
    def getInvMassMatrix(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJoint(self, index: int) -> Joint: ...
    @typing.overload
    def getJoint(self, name: str) -> Joint: ...
    def getJointConstraintImpulses(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, relativeTo: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    def getMass(self) -> float: ...
    def getMassMatrix(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    def getName(self) -> str: ...
    def getNumBodyNodes(self) -> int: ...
    def getNumDofs(self) -> int: ...
    def getNumJoints(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    @typing.overload
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getPositionLowerLimits(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    @typing.overload
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getPositionUpperLimits(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getPositions(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getVelocities(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChanges(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    @typing.overload
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getVelocityLowerLimits(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    @typing.overload
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getVelocityUpperLimits(self, indices: typing.List[int]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool: ...
    def hasJoint(self, joint: Joint) -> bool: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetGeneralizedForces(self) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    @typing.overload
    def setAccelerationLowerLimits(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setAccelerationLowerLimits(self, indices: typing.List[int], accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    @typing.overload
    def setAccelerationUpperLimits(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setAccelerationUpperLimits(self, indices: typing.List[int], accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setAccelerations(self, indices: typing.List[int], accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    @typing.overload
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setCommands(self, indices: typing.List[int], commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    @typing.overload
    def setControlForceLowerLimits(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setControlForceLowerLimits(self, indices: typing.List[int], forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    @typing.overload
    def setControlForceUpperLimits(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setControlForceUpperLimits(self, indices: typing.List[int], forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setControlForces(self, index: typing.List[int], forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setJointConstraintImpulses(self, impulses: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setName(self, name: str) -> str: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    @typing.overload
    def setPositionLowerLimits(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setPositionLowerLimits(self, indices: typing.List[int], positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    @typing.overload
    def setPositionUpperLimits(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setPositionUpperLimits(self, indices: typing.List[int], positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setPositions(self, indices: typing.List[int], positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setVelocities(self, indices: typing.List[int], velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    @typing.overload
    def setVelocityLowerLimits(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setVelocityLowerLimits(self, indices: typing.List[int], velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    @typing.overload
    def setVelocityUpperLimits(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    @typing.overload
    def setVelocityUpperLimits(self, indices: typing.List[int], velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    pass
class MultiSphereConvexHullShape(Shape):
    def __init__(self, spheres: typing.List[typing.Tuple[float, numpy.ndarray[numpy.float64, _Shape[3, 1]]]]) -> None: ...
    @typing.overload
    def addSphere(self, sphere: typing.Tuple[float, numpy.ndarray[numpy.float64, _Shape[3, 1]]]) -> None: ...
    @typing.overload
    def addSphere(self, radius: float, position: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def addSpheres(self, spheres: typing.List[typing.Tuple[float, numpy.ndarray[numpy.float64, _Shape[3, 1]]]]) -> None: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def getNumSpheres(self) -> int: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def removeAllSpheres(self) -> None: ...
    pass
class MultipleContactInverseDynamicsOverTimeResult():
    def __init__(self) -> None: ...
    def computePrevForceLoss(self) -> float: ...
    def computeSmoothnessLoss(self) -> float: ...
    def sumError(self) -> float: ...
    @property
    def accelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, n]]
        """
    @accelerations.setter
    def accelerations(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, n]]) -> None:
        pass
    @property
    def contactBodies(self) -> typing.List[BodyNode]:
        """
        :type: typing.List[BodyNode]
        """
    @contactBodies.setter
    def contactBodies(self, arg0: typing.List[BodyNode]) -> None:
        pass
    @property
    def contactWrenches(self) -> typing.List[typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]]:
        """
        :type: typing.List[typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]]
        """
    @contactWrenches.setter
    def contactWrenches(self, arg0: typing.List[typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]]) -> None:
        pass
    @property
    def jointTorques(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, n]]
        """
    @jointTorques.setter
    def jointTorques(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, n]]) -> None:
        pass
    @property
    def positions(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, n]]
        """
    @positions.setter
    def positions(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, n]]) -> None:
        pass
    @property
    def prevContactForces(self) -> typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]:
        """
        :type: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]
        """
    @prevContactForces.setter
    def prevContactForces(self, arg0: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]) -> None:
        pass
    @property
    def skel(self) -> Skeleton:
        """
        :type: Skeleton
        """
    @skel.setter
    def skel(self, arg0: Skeleton) -> None:
        pass
    @property
    def timesteps(self) -> int:
        """
        :type: int
        """
    @timesteps.setter
    def timesteps(self, arg0: int) -> None:
        pass
    @property
    def velocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, n]]
        """
    @velocities.setter
    def velocities(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, n]]) -> None:
        pass
    pass
class MultipleContactInverseDynamicsResult():
    def __init__(self) -> None: ...
    def computeGuessLoss(self) -> float: ...
    def sumError(self) -> float: ...
    @property
    def acc(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @acc.setter
    def acc(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def contactBodies(self) -> typing.List[BodyNode]:
        """
        :type: typing.List[BodyNode]
        """
    @contactBodies.setter
    def contactBodies(self, arg0: typing.List[BodyNode]) -> None:
        pass
    @property
    def contactWrenchGuesses(self) -> typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]:
        """
        :type: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]
        """
    @contactWrenchGuesses.setter
    def contactWrenchGuesses(self, arg0: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]) -> None:
        pass
    @property
    def contactWrenches(self) -> typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]:
        """
        :type: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]
        """
    @contactWrenches.setter
    def contactWrenches(self, arg0: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]]) -> None:
        pass
    @property
    def jointTorques(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @jointTorques.setter
    def jointTorques(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def pos(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @pos.setter
    def pos(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    @property
    def skel(self) -> Skeleton:
        """
        :type: Skeleton
        """
    @skel.setter
    def skel(self, arg0: Skeleton) -> None:
        pass
    @property
    def vel(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[m, 1]]
        """
    @vel.setter
    def vel(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None:
        pass
    pass
class Node():
    def getName(self) -> str: ...
    def getNodeProperties(self) -> NodeProperties: ...
    def getNodeState(self) -> NodeState: ...
    def getSkeleton(self) -> Skeleton: ...
    def isRemoved(self) -> bool: ...
    def setName(self, newName: str) -> str: ...
    def setNodeProperties(self, properties: NodeProperties) -> None: ...
    def setNodeState(self, otherState: NodeState) -> None: ...
    pass
class NodeProperties():
    pass
class NodeState():
    pass
class EmbedProperties_PlanarJoint_PlanarJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class PlanarJointUniqueProperties():
    def __init__(self) -> None: ...
    pass
class PlanarJointProperties(PlanarJointUniqueProperties):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: PlanarJointProperties) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: PlanarJointProperties, uniqueProperties: PlanarJointUniqueProperties) -> None: ...
    @property
    def mPlaneType(self) -> PlaneType:
        """
        :type: PlaneType
        """
    @mPlaneType.setter
    def mPlaneType(self, arg0: PlaneType) -> None:
        pass
    @property
    def mRotAxis(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mRotAxis.setter
    def mRotAxis(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mTransAxis1(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mTransAxis1.setter
    def mTransAxis1(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mTransAxis2(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mTransAxis2.setter
    def mTransAxis2(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    pass
class PlaneShape(Shape):
    @typing.overload
    def __init__(self, normal: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: float) -> None: ...
    @typing.overload
    def __init__(self, normal: numpy.ndarray[numpy.float64, _Shape[3, 1]], point: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def computeDistance(self, point: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> float: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def computeSignedDistance(self, point: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> float: ...
    def getNormal(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getOffset(self) -> float: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def setNormal(self, normal: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setNormalAndOffset(self, normal: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: float) -> None: ...
    def setNormalAndPoint(self, normal: numpy.ndarray[numpy.float64, _Shape[3, 1]], point: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setOffset(self, offset: float) -> None: ...
    pass
class PlaneType():
    """
    Members:

      XY

      YZ

      ZX

      ARBITRARY
    """
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str:
        """
        :type: str
        """
    @property
    def value(self) -> int:
        """
        :type: int
        """
    ARBITRARY: nimblephysics_libs._nimblephysics.dynamics.PlaneType # value = <PlaneType.ARBITRARY: 3>
    XY: nimblephysics_libs._nimblephysics.dynamics.PlaneType # value = <PlaneType.XY: 0>
    YZ: nimblephysics_libs._nimblephysics.dynamics.PlaneType # value = <PlaneType.YZ: 1>
    ZX: nimblephysics_libs._nimblephysics.dynamics.PlaneType # value = <PlaneType.ZX: 2>
    __members__: dict # value = {'XY': <PlaneType.XY: 0>, 'YZ': <PlaneType.YZ: 1>, 'ZX': <PlaneType.ZX: 2>, 'ARBITRARY': <PlaneType.ARBITRARY: 3>}
    pass
class CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class PrismaticJointUniqueProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class PrismaticJointProperties(PrismaticJointUniqueProperties):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: PrismaticJointProperties) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: PrismaticJointProperties, revoluteProperties: PrismaticJointUniqueProperties) -> None: ...
    @property
    def mAxis(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mAxis.setter
    def mAxis(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    pass
class ReferentialSkeleton(MetaSkeleton):
    def clearExternalForces(self) -> None: ...
    def clearInternalForces(self) -> None: ...
    def computeKineticEnergy(self) -> float: ...
    def computePotentialEnergy(self) -> float: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    def getBodyNodes(self, name: str) -> typing.List[BodyNode]: ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getDofs(self) -> typing.List[DegreeOfFreedom]: ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int: ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int: ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int: ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int: ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int: ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJoints(self) -> typing.List[Joint]: ...
    @typing.overload
    def getJoints(self, name: str) -> typing.List[Joint]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    def getMass(self) -> float: ...
    def getName(self) -> str: ...
    def getNumBodyNodes(self) -> int: ...
    def getNumDofs(self) -> int: ...
    def getNumJoints(self) -> int: ...
    def getNumSkeletons(self) -> int: ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool: ...
    def hasJoint(self, joint: Joint) -> bool: ...
    def hasSkeleton(self, skel: Skeleton) -> bool: ...
    def setName(self, name: str) -> str: ...
    pass
class CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space(EmbedProperties_EulerJoint_EulerJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, GenericJoint_R3, EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space(EmbedProperties_PlanarJoint_PlanarJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, GenericJoint_R3, EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space, EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EmbedProperties_ScrewJoint_ScrewJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite):
    pass
class GenericJoint_R2(EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def computePotentialEnergy(self) -> float: ...
    def copy(self, otherJoint: GenericJoint_R2) -> None: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, index: int) -> str: ...
    def getGenericJointProperties(self) -> GenericJointProperties_R2: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getNumDofs(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[2, 1]], q1: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 2]]: ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isDofNamePreserved(self, index: int) -> bool: ...
    def preserveDofName(self, index: int, preserve: bool) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, d: float) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str: ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R2) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R2) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    NumDofs = 2
    pass
class CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space(EmbedProperties_UniversalJoint_UniversalJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, GenericJoint_R2, EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_ScrewJoint_ScrewJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class CustomJoint2(GenericJoint_R2, EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def getAxisOrder(self) -> AxisOrder: ...
    def getCustomFunctionGradientAt(self, x: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getCustomFunctionPositions(self, x: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCustomFunctionSecondGradientAt(self, x: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 2]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None: ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space(CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space, EmbedProperties_PlanarJoint_PlanarJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, GenericJoint_R3, EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R4GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class GenericJoint_R6(EmbedStateAndPropertiesOnTopOf_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R6GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def computePotentialEnergy(self) -> float: ...
    def copy(self, otherJoint: GenericJoint_R6) -> None: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, index: int) -> str: ...
    def getGenericJointProperties(self) -> GenericJointProperties_R6: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getNumDofs(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[6, 1]], q1: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 6]]: ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isDofNamePreserved(self, index: int) -> bool: ...
    def preserveDofName(self, index: int, preserve: bool) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, d: float) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str: ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R6) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R6) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    NumDofs = 6
    pass
class GenericJoint_SE3(EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def computePotentialEnergy(self) -> float: ...
    def copy(self, otherJoint: GenericJoint_SE3) -> None: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, index: int) -> str: ...
    def getGenericJointProperties(self) -> GenericJointProperties_SE3: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getNumDofs(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[6, 1]], q1: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 6]]: ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isDofNamePreserved(self, index: int) -> bool: ...
    def preserveDofName(self, index: int, preserve: bool) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, d: float) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str: ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_SE3) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_SE3) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    NumDofs = 6
    pass
class GenericJoint_SO3(EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def computePotentialEnergy(self) -> float: ...
    def copy(self, otherJoint: GenericJoint_SO3) -> None: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, index: int) -> str: ...
    def getGenericJointProperties(self) -> GenericJointProperties_SO3: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getNumDofs(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[3, 1]], q1: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 3]]: ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isDofNamePreserved(self, index: int) -> bool: ...
    def preserveDofName(self, index: int, preserve: bool) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, d: float) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str: ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_SO3) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_SO3) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    NumDofs = 3
    pass
class EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space, EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class RevoluteJointUniqueProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class RevoluteJointProperties(RevoluteJointUniqueProperties):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: RevoluteJointProperties) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: RevoluteJointProperties, uniqueProperties: RevoluteJointUniqueProperties) -> None: ...
    @property
    def mAxis(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mAxis.setter
    def mAxis(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    pass
class GenericJoint_R4(EmbedStateAndPropertiesOnTopOf_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R4GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def computePotentialEnergy(self) -> float: ...
    def copy(self, otherJoint: GenericJoint_R4) -> None: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, index: int) -> str: ...
    def getGenericJointProperties(self) -> GenericJointProperties_R4: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getNumDofs(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[4, 1]], q1: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 4]]: ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isDofNamePreserved(self, index: int) -> bool: ...
    def preserveDofName(self, index: int, preserve: bool) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, d: float) -> None: ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str: ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    def setPosition(self, index: int, position: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R4) -> None: ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R4) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    NumDofs = 4
    pass
class EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space, EmbedProperties_ScrewJoint_ScrewJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class ScrewJointUniqueProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]], pitch: float) -> None: ...
    pass
class ScrewJointProperties(ScrewJointUniqueProperties):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: ScrewJointProperties) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: ScrewJointProperties, revoluteProperties: ScrewJointUniqueProperties) -> None: ...
    @property
    def mAxis(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]:
        """
        :type: numpy.ndarray[numpy.float64, _Shape[3, 1]]
        """
    @mAxis.setter
    def mAxis(self, arg0: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None:
        pass
    @property
    def mPitch(self) -> float:
        """
        :type: float
        """
    @mPitch.setter
    def mPitch(self, arg0: float) -> None:
        pass
    pass
class ArrowShape(MeshShape, Shape):
    @typing.overload
    def __init__(self, tail: numpy.ndarray[numpy.float64, _Shape[3, 1]], head: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[numpy.float64, _Shape[3, 1]], head: numpy.ndarray[numpy.float64, _Shape[3, 1]], properties: ArrowShapeProperties) -> None: ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[numpy.float64, _Shape[3, 1]], head: numpy.ndarray[numpy.float64, _Shape[3, 1]], properties: ArrowShapeProperties, color: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[numpy.float64, _Shape[3, 1]], head: numpy.ndarray[numpy.float64, _Shape[3, 1]], properties: ArrowShapeProperties, color: numpy.ndarray[numpy.float64, _Shape[4, 1]], resolution: int) -> None: ...
    def configureArrow(self, tail: numpy.ndarray[numpy.float64, _Shape[3, 1]], head: numpy.ndarray[numpy.float64, _Shape[3, 1]], properties: ArrowShapeProperties) -> None: ...
    def getHead(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getProperties(self) -> ArrowShapeProperties: ...
    def getTail(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def notifyColorUpdated(self, color: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    def setPositions(self, tail: numpy.ndarray[numpy.float64, _Shape[3, 1]], head: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setProperties(self, properties: ArrowShapeProperties) -> None: ...
    pass
class ShapeFrame(Frame, Entity):
    def createCollisionAspect(self) -> CollisionAspect: ...
    def createDynamicsAspect(self) -> DynamicsAspect: ...
    def createVisualAspect(self) -> VisualAspect: ...
    @typing.overload
    def getCollisionAspect(self) -> CollisionAspect: ...
    @typing.overload
    def getCollisionAspect(self, createIfNull: bool) -> CollisionAspect: ...
    @typing.overload
    def getDynamicsAspect(self) -> DynamicsAspect: ...
    @typing.overload
    def getDynamicsAspect(self, createIfNull: bool) -> DynamicsAspect: ...
    def getShape(self) -> Shape: ...
    @typing.overload
    def getVisualAspect(self) -> VisualAspect: ...
    @typing.overload
    def getVisualAspect(self, createIfNull: bool) -> VisualAspect: ...
    def hasCollisionAspect(self) -> bool: ...
    def hasDynamicsAspect(self) -> bool: ...
    def hasVisualAspect(self) -> bool: ...
    def isShapeNode(self) -> bool: ...
    def releaseCollisionAspect(self) -> CollisionAspect: ...
    def releaseDynamicsAspect(self) -> DynamicsAspect: ...
    def releaseVisualAspect(self) -> VisualAspect: ...
    def removeCollisionAspect(self) -> None: ...
    def removeDynamicsAspect(self) -> None: ...
    def removeVisualAspect(self) -> None: ...
    def setCollisionAspect(self, aspect: CollisionAspect) -> None: ...
    def setDynamicsAspect(self, aspect: DynamicsAspect) -> None: ...
    def setProperties(self, properties: ShapeFrameProperties) -> None: ...
    def setShape(self, shape: Shape) -> None: ...
    def setVisualAspect(self, aspect: VisualAspect) -> None: ...
    pass
class ShapeFrameProperties():
    pass
class ShapeNode(ShapeFrame, Frame, Entity):
    def copy(self, other: ShapeNode) -> None: ...
    def createCollisionAspect(self) -> CollisionAspect: ...
    def createDynamicsAspect(self) -> DynamicsAspect: ...
    def createVisualAspect(self) -> VisualAspect: ...
    def getName(self) -> str: ...
    def getOffset(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRelativeRotation(self) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def getRelativeTranslation(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getShape(self) -> Shape: ...
    def getShapeNodeProperties(self) -> ShapeNodeProperties: ...
    def getWorldTransform(self) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def setOffset(self, offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setProperties(self, properties: ShapeNodeProperties) -> None: ...
    def setRelativeRotation(self, rotation: numpy.ndarray[numpy.float64, _Shape[3, 3]]) -> None: ...
    def setRelativeTransform(self, transform: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    def setRelativeTranslation(self, translation: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class ShapeNodeProperties():
    pass
class SharedMeshWrapper():
    pass
class SimpleFrame(ShapeFrame, Frame, Entity):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, refFrame: Frame) -> None: ...
    @typing.overload
    def __init__(self, refFrame: Frame, name: str) -> None: ...
    @typing.overload
    def __init__(self, refFrame: Frame, name: str, relativeTransform: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    @typing.overload
    def clone(self) -> SimpleFrame: ...
    @typing.overload
    def clone(self, refFrame: Frame) -> SimpleFrame: ...
    @typing.overload
    def copy(self, otherFrame: Frame) -> None: ...
    @typing.overload
    def copy(self, otherFrame: Frame, refFrame: Frame) -> None: ...
    @typing.overload
    def copy(self, otherFrame: Frame, refFrame: Frame, copyProperties: bool) -> None: ...
    def getName(self) -> str: ...
    @typing.overload
    def setClassicDerivatives(self) -> None: ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], angularVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], angularVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], linearAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], angularVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], linearAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]], angularAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setName(self, name: str) -> str: ...
    def setRelativeRotation(self, newRotation: numpy.ndarray[numpy.float64, _Shape[3, 3]]) -> None: ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64, _Shape[6, 1]], inCoordinatesOf: Frame) -> None: ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64, _Shape[6, 1]], inCoordinatesOf: Frame) -> None: ...
    def setRelativeTransform(self, newRelTransform: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    def setRelativeTranslation(self, newTranslation: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setRotation(self, newRotation: numpy.ndarray[numpy.float64, _Shape[3, 3]]) -> None: ...
    @typing.overload
    def setRotation(self, newRotation: numpy.ndarray[numpy.float64, _Shape[3, 3]], withRespectTo: Frame) -> None: ...
    @typing.overload
    def setTransform(self, newTransform: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    @typing.overload
    def setTransform(self, newTransform: nimblephysics_libs._nimblephysics.math.Isometry3, withRespectTo: Frame) -> None: ...
    @typing.overload
    def setTranslation(self, newTranslation: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setTranslation(self, newTranslation: numpy.ndarray[numpy.float64, _Shape[3, 1]], withRespectTo: Frame) -> None: ...
    @typing.overload
    def spawnChildSimpleFrame(self) -> SimpleFrame: ...
    @typing.overload
    def spawnChildSimpleFrame(self, name: str) -> SimpleFrame: ...
    @typing.overload
    def spawnChildSimpleFrame(self, name: str, relativeTransform: nimblephysics_libs._nimblephysics.math.Isometry3) -> SimpleFrame: ...
    pass
class Skeleton(MetaSkeleton):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    def autogroupSymmetricPrefixes(self, firstPrefix: str = 'radius', secondPrefix: str = 'ulna') -> None: ...
    def autogroupSymmetricSuffixes(self, leftSuffix: str = '_l', rightSuffix: str = '_r') -> None: ...
    def checkIndexingConsistency(self) -> bool: ...
    def clampPositionsToLimits(self) -> None: ...
    def clearCollidingBodies(self) -> None: ...
    def clearConstraintImpulses(self) -> None: ...
    def clearExternalForces(self) -> None: ...
    def clearInternalForces(self) -> None: ...
    @typing.overload
    def clone(self) -> Skeleton: ...
    @typing.overload
    def clone(self, cloneName: str) -> Skeleton: ...
    def computeForwardDynamics(self) -> None: ...
    @typing.overload
    def computeForwardKinematics(self) -> None: ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool) -> None: ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool, updateVels: bool) -> None: ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool, updateVels: bool, updateAccs: bool) -> None: ...
    def computeImpulseForwardDynamics(self) -> None: ...
    @typing.overload
    def computeInverseDynamics(self) -> None: ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool) -> None: ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool, withDampingForces: bool) -> None: ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool, withDampingForces: bool, withSpringForces: bool) -> None: ...
    def computeKineticEnergy(self) -> float: ...
    def computePotentialEnergy(self) -> float: ...
    def convertMarkerMap(self, markerMap: typing.Dict[str, typing.Tuple[BodyNode, numpy.ndarray[numpy.float64, _Shape[3, 1]]]], warnOnDrop: bool = True) -> typing.Dict[str, typing.Tuple[BodyNode, numpy.ndarray[numpy.float64, _Shape[3, 1]]]]: ...
    def convertSensorMap(self, sensorMap: typing.Dict[str, typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]], warnOnDrop: bool = True) -> typing.Dict[str, typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]]: 
        """
        This converts markers from a source skeleton to the current, doing a
        simple mapping based on body node names. Any markers that don't find a
        body node in the current skeleton with the same name are dropped.
            
        """
    @typing.overload
    def createBallJointAndBodyNodePair(self) -> typing.Tuple[BallJoint, BodyNode]: ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[BallJoint, BodyNode]: ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode, jointProperties: BallJointProperties) -> typing.Tuple[BallJoint, BodyNode]: ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode, jointProperties: BallJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[BallJoint, BodyNode]: ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self) -> typing.Tuple[EulerJoint, BodyNode]: ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[EulerJoint, BodyNode]: ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode, jointProperties: EulerJointProperties) -> typing.Tuple[EulerJoint, BodyNode]: ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode, jointProperties: EulerJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[EulerJoint, BodyNode]: ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self) -> typing.Tuple[FreeJoint, BodyNode]: ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[FreeJoint, BodyNode]: ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode, jointProperties: FreeJointProperties) -> typing.Tuple[FreeJoint, BodyNode]: ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode, jointProperties: FreeJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[FreeJoint, BodyNode]: ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self) -> typing.Tuple[PlanarJoint, BodyNode]: ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[PlanarJoint, BodyNode]: ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PlanarJointProperties) -> typing.Tuple[PlanarJoint, BodyNode]: ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PlanarJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[PlanarJoint, BodyNode]: ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self) -> typing.Tuple[PrismaticJoint, BodyNode]: ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[PrismaticJoint, BodyNode]: ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PrismaticJointProperties) -> typing.Tuple[PrismaticJoint, BodyNode]: ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PrismaticJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[PrismaticJoint, BodyNode]: ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self) -> typing.Tuple[RevoluteJoint, BodyNode]: ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[RevoluteJoint, BodyNode]: ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode, jointProperties: RevoluteJointProperties) -> typing.Tuple[RevoluteJoint, BodyNode]: ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode, jointProperties: RevoluteJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[RevoluteJoint, BodyNode]: ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self) -> typing.Tuple[ScrewJoint, BodyNode]: ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[ScrewJoint, BodyNode]: ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode, jointProperties: ScrewJointProperties) -> typing.Tuple[ScrewJoint, BodyNode]: ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode, jointProperties: ScrewJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[ScrewJoint, BodyNode]: ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self) -> typing.Tuple[TranslationalJoint2D, BodyNode]: ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[TranslationalJoint2D, BodyNode]: ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJoint2DProperties) -> typing.Tuple[TranslationalJoint2D, BodyNode]: ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJoint2DProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[TranslationalJoint2D, BodyNode]: ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self) -> typing.Tuple[TranslationalJoint, BodyNode]: ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[TranslationalJoint, BodyNode]: ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJointProperties) -> typing.Tuple[TranslationalJoint, BodyNode]: ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[TranslationalJoint, BodyNode]: ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self) -> typing.Tuple[UniversalJoint, BodyNode]: ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[UniversalJoint, BodyNode]: ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: UniversalJointProperties) -> typing.Tuple[UniversalJoint, BodyNode]: ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: UniversalJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[UniversalJoint, BodyNode]: ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self) -> typing.Tuple[WeldJoint, BodyNode]: ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode) -> typing.Tuple[WeldJoint, BodyNode]: ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode, jointProperties: WeldJointProperties) -> typing.Tuple[WeldJoint, BodyNode]: ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode, jointProperties: WeldJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[WeldJoint, BodyNode]: ...
    def dirtyArticulatedInertia(self, treeIdx: int) -> None: ...
    def dirtySupportPolygon(self, treeIdx: int) -> None: ...
    def disableAdjacentBodyCheck(self) -> None: ...
    def disableSelfCollisionCheck(self) -> None: ...
    def enableAdjacentBodyCheck(self) -> None: ...
    def enableSelfCollisionCheck(self) -> None: ...
    def fitJointsToWorldPositions(self, positionJoints: typing.List[Joint], targetPositions: numpy.ndarray[numpy.float64, _Shape[m, 1]], scaleBodies: bool = False, convergenceThreshold: float = 1e-07, maxStepCount: int = 100, leastSquaresDamping: float = 0.01, lineSearch: bool = True, logOutput: bool = False) -> float: ...
    def fitMarkersToWorldPositions(self, markers: typing.List[typing.Tuple[BodyNode, numpy.ndarray[numpy.float64, _Shape[3, 1]]]], targetPositions: numpy.ndarray[numpy.float64, _Shape[m, 1]], markerWeights: numpy.ndarray[numpy.float64, _Shape[m, 1]], scaleBodies: bool = False, convergenceThreshold: float = 1e-07, maxStepCount: int = 100, leastSquaresDamping: float = 0.01, lineSearch: bool = True, logOutput: bool = False) -> float: ...
    def getAccMapReadings(self, accelerometers: typing.Dict[str, typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]]) -> typing.Dict[str, numpy.ndarray[numpy.float64, _Shape[3, 1]]]: 
        """
        These are a set of bodies, and offsets in local body space where gyros
        are mounted on the body
            
        """
    def getAccelerometerReadings(self, accelerometers: typing.List[typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: 
        """
        These are a set of bodies, and offsets in local body space where accs are mounted on the body.
            
        """
    def getAccelerometerReadingsJacobianWrt(self, accs: typing.List[typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]], wrt: nimblephysics_libs._nimblephysics.neural.WithRespectTo) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: 
        """
        This returns the Jacobian relating changes in the `wrt` quantity to changes in acc readings.
            
        """
    def getAdjacentBodyCheck(self) -> bool: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, rotation: numpy.ndarray[numpy.float64, _Shape[3, 3]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getAugMassMatrix(self, arg0: int) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    @typing.overload
    def getAugMassMatrix(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    def getBodyForMesh(self, meshFileName: str) -> BodyNode: ...
    def getBodyLocalAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyLocalVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getBodyNode(self, arg0: int) -> BodyNode: ...
    @typing.overload
    def getBodyNode(self, index: int) -> BodyNode: ...
    @typing.overload
    def getBodyNode(self, treeIndex: str) -> BodyNode: ...
    def getBodyScaleGroup(self, index: int) -> BodyScaleGroup: ...
    def getBodyScaleGroups(self) -> typing.List[BodyScaleGroup]: ...
    def getBodyScales(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getConstraintForces(self, arg0: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getConstraintForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getContactInverseDynamics(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]], contactBody: BodyNode) -> ContactInverseDynamicsResult: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getCoriolisAndGravityForces(self, arg0: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getCoriolisAndGravityForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getCoriolisForces(self, arg0: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getCoriolisForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getDof(self, name: str) -> DegreeOfFreedom: ...
    def getDofByIndex(self, index: int) -> DegreeOfFreedom: ...
    def getEnergyAccounting(self, heightAtZeroPoint: float = 0, referenceFrameVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]] = array([0., 0., 0.]), contactBodies: typing.List[BodyNode] = [], cops: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]] = [], forces: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]] = [], moments: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]]] = []) -> EnergyAccountingFrame: ...
    @typing.overload
    def getExternalForces(self, arg0: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getExternalForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGradientOfHeightWrtBodyScales(self, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], up: numpy.ndarray[numpy.float64, _Shape[3, 1]] = array([0., 1., 0.])) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGradientOfLowestPointWrtBodyScales(self, up: numpy.ndarray[numpy.float64, _Shape[3, 1]] = array([0., 1., 0.])) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGradientOfLowestPointWrtJoints(self, up: numpy.ndarray[numpy.float64, _Shape[3, 1]] = array([0., 1., 0.])) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGravity(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getGravityForces(self, arg0: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getGravityForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupCOMLowerBound(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupCOMUpperBound(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupCOMs(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupInertias(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupInertiasLowerBound(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupInertiasUpperBound(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupMasses(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupMassesLowerBound(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupMassesUpperBound(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGroupScaleDim(self) -> int: ...
    def getGroupScales(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getGyroMapReadings(self, gyros: typing.Dict[str, typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]]) -> typing.Dict[str, numpy.ndarray[numpy.float64, _Shape[3, 1]]]: 
        """
        These are a set of bodies, and offsets in local body space where gyros
        are mounted on the body
            
        """
    def getGyroReadings(self, gyros: typing.List[typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: 
        """
        These are a set of bodies, and offsets in local body space where gyros are mounted on the body.
            
        """
    def getGyroReadingsJacobianWrt(self, gyros: typing.List[typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]], wrt: nimblephysics_libs._nimblephysics.neural.WithRespectTo) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: 
        """
        This returns the Jacobian relating changes in the `wrt` quantity to changes in gyro readings.
            
        """
    def getHeight(self, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], up: numpy.ndarray[numpy.float64, _Shape[3, 1]] = array([0., 1., 0.])) -> float: ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int: ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int: ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int: ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int: ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int: ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int: ...
    @typing.overload
    def getInvMassMatrix(self, arg0: int) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    @typing.overload
    def getInvMassMatrix(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    def getInverseDynamics(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInverseDynamicsFromPredictions(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]], contactBodies: typing.List[BodyNode], rootFrameContactWrench: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]], rootResiduals: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getJoint(self, idx: int) -> Joint: ...
    @typing.overload
    def getJoint(self, name: str) -> Joint: ...
    def getJointWorldPositions(self, joints: typing.List[Joint]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getJointWorldPositionsJacobianWrtBodyScales(self, joints: typing.List[Joint]) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    def getJointWorldPositionsJacobianWrtGroupScales(self, joints: typing.List[Joint]) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    def getJointWorldPositionsJacobianWrtJointPositions(self, joints: typing.List[Joint]) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    def getJointWorldPositionsMap(self) -> typing.Dict[str, numpy.ndarray[numpy.float64, _Shape[3, 1]]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], rotation: numpy.ndarray[numpy.float64, _Shape[3, 3]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, n]]: ...
    def getLinearizedMasses(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getLinkMasses(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getLowestPoint(self, up: numpy.ndarray[numpy.float64, _Shape[3, 1]] = array([0., 1., 0.])) -> float: ...
    def getMagnetometerReadings(self, mags: typing.List[typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]], magneticField: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: 
        """
        These are a set of bodies, and offsets in local body space where magnetometers are mounted on the body.
            
        """
    def getMagnetometerReadingsJacobianWrt(self, mags: typing.List[typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]], magneticField: numpy.ndarray[numpy.float64, _Shape[3, 1]], wrt: nimblephysics_libs._nimblephysics.neural.WithRespectTo) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: 
        """
        This returns the Jacobian relating changes in the `wrt` quantity to changes in mag readings.
            
        """
    def getMagnetometerReadingsJacobianWrtMagneticField(self, mags: typing.List[typing.Tuple[BodyNode, nimblephysics_libs._nimblephysics.math.Isometry3]], magneticField: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: 
        """
        This returns the Jacobian relating changes in the magnetic field to changes in mag readings.
            
        """
    def getMarkerMapWorldPositions(self, markerMap: typing.Dict[str, typing.Tuple[BodyNode, numpy.ndarray[numpy.float64, _Shape[3, 1]]]]) -> typing.Dict[str, numpy.ndarray[numpy.float64, _Shape[3, 1]]]: ...
    def getMarkerWorldPositions(self, markers: typing.List[typing.Tuple[BodyNode, numpy.ndarray[numpy.float64, _Shape[3, 1]]]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getMass(self) -> float: ...
    @typing.overload
    def getMassMatrix(self, arg0: int) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    @typing.overload
    def getMassMatrix(self) -> numpy.ndarray[numpy.float64, _Shape[m, n]]: ...
    def getMultipleContactInverseDynamics(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]], contactBodies: typing.List[BodyNode], bodyWrenchGuesses: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]] = []) -> MultipleContactInverseDynamicsResult: ...
    def getMultipleContactInverseDynamicsOverTime(self, positions: numpy.ndarray[numpy.float64, _Shape[m, n]], contactBodies: typing.List[BodyNode], smoothingWeight: float, minTorqueWeight: float, velocityPenalty: typing.Callable[[float], float], prevContactForces: typing.List[numpy.ndarray[numpy.float64, _Shape[6, 1]]] = [], prevContactWeight: float = 0.0, magnitudeCosts: numpy.ndarray[numpy.float64, _Shape[m, n]] = array([], shape=(0, 0), dtype=float64)) -> MultipleContactInverseDynamicsOverTimeResult: ...
    def getName(self) -> str: ...
    def getNumBodyNodes(self) -> int: ...
    def getNumDofs(self) -> int: ...
    @typing.overload
    def getNumEndEffectors(self) -> int: ...
    @typing.overload
    def getNumEndEffectors(self, treeIndex: int) -> int: ...
    def getNumJoints(self) -> int: ...
    @typing.overload
    def getNumMarkers(self) -> int: ...
    @typing.overload
    def getNumMarkers(self, treeIndex: int) -> int: ...
    def getNumRigidBodyNodes(self) -> int: ...
    @typing.overload
    def getNumShapeNodes(self) -> int: ...
    @typing.overload
    def getNumShapeNodes(self, treeIndex: int) -> int: ...
    def getNumSoftBodyNodes(self) -> int: ...
    def getNumTrees(self) -> int: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getProperties(self) -> ShapeNodeProperties: ...
    def getPtr(self) -> Skeleton: ...
    def getRandomPose(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getRandomPoseForJoints(self, joints: typing.List[Joint]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getRootBodyNode(self) -> BodyNode: ...
    @typing.overload
    def getRootBodyNode(self, treeIndex: int) -> BodyNode: ...
    @typing.overload
    def getRootJoint(self) -> Joint: ...
    @typing.overload
    def getRootJoint(self, treeIndex: int) -> Joint: ...
    def getRotationFromMeshToParentBody(self, meshFileName: str, relativeToGeometry: numpy.ndarray[numpy.float64, _Shape[3, 3]]) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def getScaleGroupIndex(self, bodyNode: BodyNode) -> int: ...
    def getScaleGroupLowerBound(self, index: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getScaleGroupUpperBound(self, index: int) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getSelfCollisionCheck(self) -> bool: ...
    def getSkeleton(self) -> Skeleton: ...
    @typing.overload
    def getSupportVersion(self) -> int: ...
    @typing.overload
    def getSupportVersion(self, treeIdx: int) -> int: ...
    def getTimeStep(self) -> float: ...
    def getTransformFromMeshToParentBody(self, meshFileName: str, relativeToGeometry: nimblephysics_libs._nimblephysics.math.Isometry3) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def getTranslationFromMeshToParentBody(self, meshFileName: str, relativeToGeometry: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getTreeBodyNodes(self, treeIdx: int) -> typing.List[BodyNode]: ...
    def getVelocityDifferences(self, dq2: numpy.ndarray[numpy.float64, _Shape[m, 1]], dq1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool: ...
    def hasJoint(self, joint: Joint) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integratePositionsExplicit(self, pos: numpy.ndarray[numpy.float64, _Shape[m, 1]], vel: numpy.ndarray[numpy.float64, _Shape[m, 1]], dt: float) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isEnabledAdjacentBodyCheck(self) -> bool: ...
    def isEnabledSelfCollisionCheck(self) -> bool: ...
    def isImpulseApplied(self) -> bool: ...
    def isMobile(self) -> bool: ...
    def mergeScaleGroups(self, bodyNodeA: BodyNode, bodyNodeB: BodyNode) -> None: ...
    def mergeScaleGroupsByIndex(self, groupA: int, groupB: int) -> None: ...
    def resetUnion(self) -> None: ...
    def setAdjacentBodyCheck(self, enable: bool) -> None: ...
    def setBodyScales(self, scales: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForcesLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForcesUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setGravity(self, gravity: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setGroupCOMs(self, coms: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setGroupInertias(self, inertias: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setGroupMasses(self, masses: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setGroupScales(self, scales: numpy.ndarray[numpy.float64, _Shape[m, 1]], silentlyClamp: bool = False) -> None: ...
    def setImpulseApplied(self, val: bool) -> None: ...
    def setLinearizedMasses(self, masses: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setLinkMasses(self, masses: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setMobile(self, isMobile: bool) -> None: ...
    def setName(self, name: str) -> str: ...
    def setPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setProperties(self, properties: ShapeNodeProperties) -> None: ...
    def setScaleGroupUniformScaling(self, bodyNode: BodyNode, uniform: bool = True) -> None: ...
    def setSelfCollisionCheck(self, enable: bool) -> None: ...
    def setTimeStep(self, timeStep: float) -> None: ...
    def setVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def simplifySkeleton(self, cloneName: str, mergeBodiesInto: typing.Dict[str, str]) -> Skeleton: ...
    def unwrapPositionToNearest(self, thisPos: numpy.ndarray[numpy.float64, _Shape[m, 1]], lastPos: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode: BodyNode) -> None: ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode: BodyNode, imp: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode1: BodyNode, imp1: numpy.ndarray[numpy.float64, _Shape[6, 1]], bodyNode2: BodyNode, imp2: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    def updateVelocityChange(self) -> None: ...
    @property
    def mUnionIndex(self) -> int:
        """
        :type: int
        """
    @mUnionIndex.setter
    def mUnionIndex(self, arg0: int) -> None:
        pass
    @property
    def mUnionSize(self) -> int:
        """
        :type: int
        """
    @mUnionSize.setter
    def mUnionSize(self, arg0: int) -> None:
        pass
    pass
class EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space(CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space, EmbedProperties_EulerJoint_EulerJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, GenericJoint_R3, EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class PlanarJoint(EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space, CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space, EmbedProperties_PlanarJoint_PlanarJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties, GenericJoint_R3, EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def copy(self, otherJoint: PlanarJoint) -> None: ...
    def getPlanarJointProperties(self) -> PlanarJointProperties: ...
    def getPlaneType(self) -> PlaneType: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 3]]: ...
    def getRotationalAxis(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getTranslationalAxis1(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getTranslationalAxis2(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[numpy.float64, _Shape[3, 1]], transAxis2: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[numpy.float64, _Shape[3, 1]], transAxis2: numpy.ndarray[numpy.float64, _Shape[3, 1]], renameDofs: bool) -> None: ...
    @typing.overload
    def setProperties(self, properties: PlanarJointProperties) -> None: ...
    @typing.overload
    def setProperties(self, properties: PlanarJointUniqueProperties) -> None: ...
    @typing.overload
    def setXYPlane(self) -> None: ...
    @typing.overload
    def setXYPlane(self, renameDofs: bool) -> None: ...
    @typing.overload
    def setYZPlane(self) -> None: ...
    @typing.overload
    def setYZPlane(self, renameDofs: bool) -> None: ...
    @typing.overload
    def setZXPlane(self) -> None: ...
    @typing.overload
    def setZXPlane(self, renameDofs: bool) -> None: ...
    pass
class PrismaticJoint(EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space, CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space, EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def copy(self, otherJoint: PrismaticJoint) -> None: ...
    def getAxis(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getPrismaticJointProperties(self) -> PrismaticJointProperties: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    def setAxis(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: PrismaticJointProperties) -> None: ...
    @typing.overload
    def setProperties(self, properties: PrismaticJointUniqueProperties) -> None: ...
    pass
class RevoluteJoint(EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space, CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space, EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def copy(self, otherJoint: RevoluteJoint) -> None: ...
    def getAxis(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getRevoluteJointProperties(self) -> RevoluteJointProperties: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    def setAxis(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: RevoluteJointProperties) -> None: ...
    @typing.overload
    def setProperties(self, properties: RevoluteJointUniqueProperties) -> None: ...
    pass
class ScrewJoint(EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space, CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space, EmbedProperties_ScrewJoint_ScrewJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties, GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def copy(self, otherJoint: ScrewJoint) -> None: ...
    def getAxis(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getPitch(self) -> float: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getScrewJointProperties(self) -> ScrewJointProperties: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    def setAxis(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setPitch(self, pitch: float) -> None: ...
    @typing.overload
    def setProperties(self, properties: ScrewJointProperties) -> None: ...
    @typing.overload
    def setProperties(self, properties: ScrewJointUniqueProperties) -> None: ...
    pass
class CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space(EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, GenericJoint_R2, EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space(CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space, EmbedProperties_UniversalJoint_UniversalJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, GenericJoint_R2, EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class CustomJoint1(GenericJoint_R1, EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def getAxisOrder(self) -> AxisOrder: ...
    def getCustomFunctionGradientAt(self, x: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getCustomFunctionPositions(self, x: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCustomFunctionSecondGradientAt(self, x: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, n]]: ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[1, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None: ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space(CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space, EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, GenericJoint_R2, EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    pass
class EulerJoint(EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space, CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space, EmbedProperties_EulerJoint_EulerJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties, GenericJoint_R3, EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def convertToRotation(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def convertToRotationOf(positions: numpy.ndarray[numpy.float64, _Shape[3, 1]], ordering: AxisOrder, flipAxisMap: numpy.ndarray[numpy.float64, _Shape[3, 1]] = array([1., 1., 1.])) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    def convertToTransform(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    @staticmethod
    def convertToTransformOf(positions: numpy.ndarray[numpy.float64, _Shape[3, 1]], ordering: AxisOrder, flipAxisMap: numpy.ndarray[numpy.float64, _Shape[3, 1]] = array([1., 1., 1.])) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def copy(self, otherJoint: EulerJoint) -> None: ...
    def getAxisOrder(self) -> AxisOrder: ...
    def getEulerJointProperties(self) -> EulerJointProperties: ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 3]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    @typing.overload
    def setAxisOrder(self, order: AxisOrder) -> None: ...
    @typing.overload
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None: ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: EulerJointProperties) -> None: ...
    @typing.overload
    def setProperties(self, properties: EulerJointUniqueProperties) -> None: ...
    pass
class ScapulothoracicJoint(GenericJoint_R4, EmbedStateAndPropertiesOnTopOf_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R4GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def getAxisOrder(self) -> AxisOrder: ...
    def getEllipsoidRadii(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 4]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def getWingingAxisDirection(self) -> float: ...
    def getWingingAxisOffset(self) -> numpy.ndarray[numpy.float64, _Shape[2, 1]]: ...
    def isCyclic(self, index: int) -> bool: ...
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None: ...
    def setEllipsoidRadii(self, radii: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    def setWingingAxisDirection(self, direction: float) -> None: ...
    def setWingingAxisOffset(self, offset: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> None: ...
    pass
class EulerFreeJoint(GenericJoint_R6, EmbedStateAndPropertiesOnTopOf_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R6GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def getAxisOrder(self) -> AxisOrder: ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 6]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None: ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    pass
class FreeJoint(GenericJoint_SE3, EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    @staticmethod
    def convertToPositions(tf: nimblephysics_libs._nimblephysics.math.Isometry3) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @staticmethod
    def convertToTransform(positions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def getFreeJointProperties(self) -> FreeJointProperties: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[6, 1]], q1: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 6]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame) -> None: ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None: ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame) -> None: ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None: ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame) -> None: ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None: ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame) -> None: ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[numpy.float64, _Shape[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None: ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64, _Shape[6, 1]], inCoordinatesOf: Frame) -> None: ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64, _Shape[6, 1]], inCoordinatesOf: Frame) -> None: ...
    def setRelativeTransform(self, newTransform: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    def setSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64, _Shape[6, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None: ...
    def setSpatialMotion(self, newTransform: nimblephysics_libs._nimblephysics.math.Isometry3, withRespectTo: Frame, newSpatialVelocity: numpy.ndarray[numpy.float64, _Shape[6, 1]], velRelativeTo: Frame, velInCoordinatesOf: Frame, newSpatialAcceleration: numpy.ndarray[numpy.float64, _Shape[6, 1]], accRelativeTo: Frame, accInCoordinatesOf: Frame) -> None: ...
    def setSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64, _Shape[6, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None: ...
    @typing.overload
    def setTransform(self, newTransform: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    @typing.overload
    def setTransform(self, newTransform: nimblephysics_libs._nimblephysics.math.Isometry3, withRespectTo: Frame) -> None: ...
    @staticmethod
    @typing.overload
    def setTransformOf(joint: Joint, tf: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    @staticmethod
    @typing.overload
    def setTransformOf(joint: Joint, tf: nimblephysics_libs._nimblephysics.math.Isometry3, withRespectTo: Frame) -> None: ...
    @staticmethod
    @typing.overload
    def setTransformOf(bodyNode: BodyNode, tf: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    @staticmethod
    @typing.overload
    def setTransformOf(bodyNode: BodyNode, tf: nimblephysics_libs._nimblephysics.math.Isometry3, withRespectTo: Frame) -> None: ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: Skeleton, tf: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: Skeleton, tf: nimblephysics_libs._nimblephysics.math.Isometry3, withRespectTo: Frame) -> None: ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: Skeleton, tf: nimblephysics_libs._nimblephysics.math.Isometry3, withRespectTo: Frame, applyToAllRootBodies: bool) -> None: ...
    pass
class BallJoint(GenericJoint_SO3, EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    @staticmethod
    def convertToRotation(positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def convertToTransform(positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> nimblephysics_libs._nimblephysics.math.Isometry3: ...
    def getBallJointProperties(self) -> BallJointProperties: ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64, _Shape[3, 1]], q1: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 3]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    pass
class SphereShape(Shape):
    def __init__(self, radius: float) -> None: ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeInertiaOf(radius: float, mass: float) -> numpy.ndarray[numpy.float64, _Shape[3, 3]]: ...
    @staticmethod
    def computeVolumeOf(radius: float) -> float: ...
    def getRadius(self) -> float: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def setRadius(self, radius: float) -> None: ...
    pass
class BodyNode(TemplatedJacobianBodyNode, JacobianNode, Frame, Entity):
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], isImpulseLocal: bool) -> None: ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], isImpulseLocal: bool, isOffsetLocal: bool) -> None: ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], isForceLocal: bool) -> None: ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], isForceLocal: bool, isOffsetLocal: bool) -> None: ...
    @typing.overload
    def addExtTorque(self, torque: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def addExtTorque(self, torque: numpy.ndarray[numpy.float64, _Shape[3, 1]], isLocal: bool) -> None: ...
    def clearConstraintImpulse(self) -> None: ...
    def clearExternalForces(self) -> None: ...
    def clearInternalForces(self) -> None: ...
    def computeKineticEnergy(self) -> float: ...
    def computeLagrangian(self, gravity: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> float: ...
    def computePotentialEnergy(self, gravity: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> float: ...
    def copy(self, otherBodyNode: BodyNode) -> None: ...
    @typing.overload
    def copyAs(self, skeletonName: str) -> Skeleton: ...
    @typing.overload
    def copyAs(self, skeletonName: str, recursive: bool) -> Skeleton: ...
    @typing.overload
    def copyTo(self, newParent: BodyNode) -> typing.Tuple[Joint, BodyNode]: ...
    @typing.overload
    def copyTo(self, newParent: BodyNode, recursive: bool) -> typing.Tuple[Joint, BodyNode]: ...
    @typing.overload
    def copyTo(self, newSkeleton: Skeleton, newParent: BodyNode) -> typing.Tuple[Joint, BodyNode]: ...
    @typing.overload
    def copyTo(self, newSkeleton: Skeleton, newParent: BodyNode, recursive: bool) -> typing.Tuple[Joint, BodyNode]: ...
    @typing.overload
    def createBallJointAndBodyNodePair(self) -> typing.Tuple[BallJoint, BodyNode]: ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, jointProperties: BallJointProperties) -> typing.Tuple[BallJoint, BodyNode]: ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, jointProperties: BallJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[BallJoint, BodyNode]: ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self) -> typing.Tuple[EulerJoint, BodyNode]: ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, jointProperties: EulerJointProperties) -> typing.Tuple[EulerJoint, BodyNode]: ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, jointProperties: EulerJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[EulerJoint, BodyNode]: ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self) -> typing.Tuple[FreeJoint, BodyNode]: ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, jointProperties: FreeJointProperties) -> typing.Tuple[FreeJoint, BodyNode]: ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, jointProperties: FreeJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[FreeJoint, BodyNode]: ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self) -> typing.Tuple[PlanarJoint, BodyNode]: ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, jointProperties: PlanarJointProperties) -> typing.Tuple[PlanarJoint, BodyNode]: ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, jointProperties: PlanarJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[PlanarJoint, BodyNode]: ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self) -> typing.Tuple[PrismaticJoint, BodyNode]: ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, jointProperties: PrismaticJointProperties) -> typing.Tuple[PrismaticJoint, BodyNode]: ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, jointProperties: PrismaticJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[PrismaticJoint, BodyNode]: ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self) -> typing.Tuple[RevoluteJoint, BodyNode]: ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, jointProperties: RevoluteJointProperties) -> typing.Tuple[RevoluteJoint, BodyNode]: ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, jointProperties: RevoluteJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[RevoluteJoint, BodyNode]: ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self) -> typing.Tuple[ScrewJoint, BodyNode]: ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, jointProperties: ScrewJointProperties) -> typing.Tuple[ScrewJoint, BodyNode]: ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, jointProperties: ScrewJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[ScrewJoint, BodyNode]: ...
    @typing.overload
    def createShapeNode(self, shape: Shape) -> ShapeNode: ...
    @typing.overload
    def createShapeNode(self, shape: Shape, name: str) -> ShapeNode: ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self) -> typing.Tuple[TranslationalJoint2D, BodyNode]: ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, jointProperties: TranslationalJoint2DProperties) -> typing.Tuple[TranslationalJoint2D, BodyNode]: ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, jointProperties: TranslationalJoint2DProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[TranslationalJoint2D, BodyNode]: ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self) -> typing.Tuple[TranslationalJoint, BodyNode]: ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, jointProperties: TranslationalJointProperties) -> typing.Tuple[TranslationalJoint, BodyNode]: ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, jointProperties: TranslationalJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[TranslationalJoint, BodyNode]: ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self) -> typing.Tuple[UniversalJoint, BodyNode]: ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, jointProperties: UniversalJointProperties) -> typing.Tuple[UniversalJoint, BodyNode]: ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, jointProperties: UniversalJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[UniversalJoint, BodyNode]: ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self) -> typing.Tuple[WeldJoint, BodyNode]: ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, jointProperties: WeldJointProperties) -> typing.Tuple[WeldJoint, BodyNode]: ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, jointProperties: WeldJointProperties, bodyProperties: BodyNodeProperties) -> typing.Tuple[WeldJoint, BodyNode]: ...
    def dependsOn(self, genCoordIndex: int) -> bool: ...
    def dirtyAcceleration(self) -> None: ...
    def dirtyArticulatedInertia(self) -> None: ...
    def dirtyCoriolisForces(self) -> None: ...
    def dirtyExternalForces(self) -> None: ...
    def dirtyTransform(self) -> None: ...
    def dirtyVelocity(self) -> None: ...
    def duplicateNodes(self, otherBodyNode: BodyNode) -> None: ...
    @typing.overload
    def getAngularMomentum(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getAngularMomentum(self, pivot: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getBodyNodeProperties(self) -> BodyNodeProperties: ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getChildJoint(self, index: int) -> Joint: ...
    def getClosestVerticesToMarker(self, marker: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getConstraintImpulse(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getDependentGenCoordIndex(self, arrayIndex: int) -> int: ...
    def getDistToClosestVerticesToMarker(self, marker: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> float: ...
    def getExternalForceGlobal(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getExternalForceLocal(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getFrictionCoeff(self) -> float: ...
    def getGradientOfDistToClosestVerticesToMarkerWrtBodyScale(self, marker: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getGradientOfDistToClosestVerticesToMarkerWrtMarker(self, marker: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getGravityMode(self) -> bool: ...
    def getIndexInSkeleton(self) -> int: ...
    def getIndexInTree(self) -> int: ...
    def getLinearMomentum(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getLocalCOM(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getMass(self) -> float: ...
    def getMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    def getName(self) -> str: ...
    def getNumChildBodyNodes(self) -> int: ...
    def getNumChildJoints(self) -> int: ...
    def getNumDependentDofs(self) -> int: ...
    def getNumDependentGenCoords(self) -> int: ...
    def getNumEndEffectors(self) -> int: ...
    def getNumMarkers(self) -> int: ...
    def getNumShapeNodes(self) -> int: ...
    def getParentBodyNode(self) -> BodyNode: ...
    def getParentJoint(self) -> Joint: ...
    def getRestitutionCoeff(self) -> float: ...
    def getScale(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getScaleLowerBound(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getScaleUpperBound(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getShapeNode(self, index: int) -> ShapeNode: ...
    def getSkeleton(self) -> Skeleton: ...
    def getTreeIndex(self) -> int: ...
    def isCollidable(self) -> bool: ...
    def isReactive(self) -> bool: ...
    def matchNodes(self, otherBodyNode: BodyNode) -> None: ...
    @typing.overload
    def moveTo(self, newParent: BodyNode) -> bool: ...
    @typing.overload
    def moveTo(self, newSkeleton: Skeleton, newParent: BodyNode) -> bool: ...
    @typing.overload
    def remove(self) -> Skeleton: ...
    @typing.overload
    def remove(self, name: str) -> Skeleton: ...
    def removeAllShapeNodes(self) -> None: ...
    def setCollidable(self, isCollidable: bool) -> None: ...
    def setConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], isForceLocal: bool) -> None: ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[numpy.float64, _Shape[3, 1]], offset: numpy.ndarray[numpy.float64, _Shape[3, 1]], isForceLocal: bool, isOffsetLocal: bool) -> None: ...
    @typing.overload
    def setExtTorque(self, torque: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setExtTorque(self, torque: numpy.ndarray[numpy.float64, _Shape[3, 1]], isLocal: bool) -> None: ...
    def setExtWrench(self, wrench: numpy.ndarray[numpy.float64, _Shape[6, 1]]) -> None: ...
    def setFrictionCoeff(self, coeff: float) -> None: ...
    def setGravityMode(self, gravityMode: bool) -> None: ...
    def setInertia(self, inertia: Inertia) -> None: ...
    def setLocalCOM(self, com: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setMass(self, mass: float) -> None: ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float) -> None: ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float) -> None: ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float) -> None: ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None: ...
    def setName(self, name: str) -> None: ...
    def setRestitutionCoeff(self, coeff: float) -> None: ...
    def setScale(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]], silentlyClamp: bool = False) -> None: ...
    def setScaleLowerBound(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setScaleUpperBound(self, scale: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def split(self, skeletonName: str) -> Skeleton: ...
    pass
class TranslationalJoint(GenericJoint_R3, EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 3]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getTranslationalJointProperties(self) -> TranslationalJointProperties: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    pass
class TranslationalJoint2D(EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space, CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space, EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, GenericJoint_R2, EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def copy(self, otherJoint: TranslationalJoint2D) -> None: ...
    def getPlaneType(self) -> PlaneType: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 2]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getTranslationalAxis1(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getTranslationalAxis2(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getTranslationalJoint2DProperties(self) -> TranslationalJoint2DProperties: ...
    def getType(self) -> str: ...
    def isCyclic(self, index: int) -> bool: ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[numpy.float64, _Shape[3, 1]], transAxis2: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[numpy.float64, _Shape[3, 1]], transAxis2: numpy.ndarray[numpy.float64, _Shape[3, 1]], renameDofs: bool) -> None: ...
    @typing.overload
    def setProperties(self, properties: TranslationalJoint2DProperties) -> None: ...
    @typing.overload
    def setProperties(self, properties: TranslationalJoint2DUniqueProperties) -> None: ...
    @typing.overload
    def setXYPlane(self) -> None: ...
    @typing.overload
    def setXYPlane(self, renameDofs: bool) -> None: ...
    @typing.overload
    def setYZPlane(self) -> None: ...
    @typing.overload
    def setYZPlane(self, renameDofs: bool) -> None: ...
    @typing.overload
    def setZXPlane(self) -> None: ...
    @typing.overload
    def setZXPlane(self, renameDofs: bool) -> None: ...
    pass
class TranslationalJoint2DUniqueProperties():
    def __init__(self) -> None: ...
    pass
class TranslationalJoint2DProperties(TranslationalJoint2DUniqueProperties):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: TranslationalJoint2DProperties) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: TranslationalJoint2DProperties, uniqueProperties: TranslationalJoint2DUniqueProperties) -> None: ...
    pass
class TranslationalJointProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, properties: TranslationalJointProperties) -> None: ...
    pass
class UniversalJoint(EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space, CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space, EmbedProperties_UniversalJoint_UniversalJointUniqueProperties, RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties, GenericJoint_R2, EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint, CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint, EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties, nimblephysics_libs._nimblephysics.common.Composite, Joint):
    def copy(self, otherJoint: UniversalJoint) -> None: ...
    def getAxis1(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getAxis2(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64, _Shape[2, 1]]) -> numpy.ndarray[numpy.float64, _Shape[6, 2]]: ...
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def getUniversalJointProperties(self) -> UniversalJointProperties: ...
    def isCyclic(self, index: int) -> bool: ...
    def setAxis1(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setAxis2(self, axis: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setProperties(self, properties: UniversalJointProperties) -> None: ...
    @typing.overload
    def setProperties(self, properties: UniversalJointUniqueProperties) -> None: ...
    pass
class UniversalJointUniqueProperties():
    def __init__(self) -> None: ...
    pass
class UniversalJointProperties(UniversalJointUniqueProperties):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: UniversalJointProperties) -> None: ...
    @typing.overload
    def __init__(self, genericJointProperties: UniversalJointProperties, uniqueProperties: UniversalJointUniqueProperties) -> None: ...
    @property
    def mAxis(self) -> typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]][2]]:
        """
        :type: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]][2]]
        """
    @mAxis.setter
    def mAxis(self, arg0: typing.List[numpy.ndarray[numpy.float64, _Shape[3, 1]][2]]) -> None:
        pass
    pass
class VisualAspect():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, properties: VisualAspectProperties) -> None: ...
    def getAlpha(self) -> float: ...
    def getCastShadows(self) -> bool: ...
    def getColor(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getHidden(self) -> bool: ...
    def getRGB(self) -> numpy.ndarray[numpy.float64, _Shape[3, 1]]: ...
    def getRGBA(self) -> numpy.ndarray[numpy.float64, _Shape[4, 1]]: ...
    def getReceiveShadows(self) -> bool: ...
    def hide(self) -> None: ...
    def isHidden(self) -> bool: ...
    def setAlpha(self, alpha: float) -> None: ...
    def setCastShadows(self, value: bool) -> None: ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    def setHidden(self, value: bool) -> None: ...
    def setRGB(self, rgb: numpy.ndarray[numpy.float64, _Shape[3, 1]]) -> None: ...
    def setRGBA(self, color: numpy.ndarray[numpy.float64, _Shape[4, 1]]) -> None: ...
    def setReceiveShadows(self, value: bool) -> None: ...
    def show(self) -> None: ...
    pass
class VisualAspectProperties():
    pass
class ZeroDofJoint(Joint):
    def computePotentialEnergy(self) -> float: ...
    def getAcceleration(self, index: int) -> float: ...
    def getAccelerationLowerLimit(self, index: int) -> float: ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerationUpperLimit(self, index: int) -> float: ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64, _Shape[6, 1]]: ...
    def getCommand(self, index: int) -> float: ...
    def getCommands(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getConstraintImpulse(self, index: int) -> float: ...
    def getControlForce(self, index: int) -> float: ...
    def getControlForceLowerLimit(self, index: int) -> float: ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForceUpperLimit(self, index: int) -> float: ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getCoulombFriction(self, index: int) -> float: ...
    def getDampingCoefficient(self, index: int) -> float: ...
    def getDofName(self, arg0_: int) -> str: ...
    def getIndexInSkeleton(self, index: int) -> int: ...
    def getIndexInTree(self, index: int) -> int: ...
    def getInitialPosition(self, index: int) -> float: ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getInitialVelocity(self, index: int) -> float: ...
    def getNumDofs(self) -> int: ...
    def getPosition(self, index: int) -> float: ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64, _Shape[m, 1]], q1: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionLowerLimit(self, index: int) -> float: ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositionUpperLimit(self, index: int) -> float: ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getPositions(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getRestPosition(self, index: int) -> float: ...
    def getSpringStiffness(self, index: int) -> float: ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocity(self, index: int) -> float: ...
    def getVelocityChange(self, index: int) -> float: ...
    def getVelocityLowerLimit(self, index: int) -> float: ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getVelocityUpperLimit(self, index: int) -> float: ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64, _Shape[m, 1]]: ...
    def getZeroDofJointProperties(self) -> ZeroDofJointProperties: ...
    def hasPositionLimit(self, index: int) -> bool: ...
    def integratePositions(self, dt: float) -> None: ...
    def integrateVelocities(self, dt: float) -> None: ...
    def isDofNamePreserved(self, arg0_: int) -> bool: ...
    def preserveDofName(self, arg0_: int, arg1_: bool) -> None: ...
    def resetAccelerations(self) -> None: ...
    def resetCommands(self) -> None: ...
    def resetConstraintImpulses(self) -> None: ...
    def resetControlForces(self) -> None: ...
    def resetPosition(self, index: int) -> None: ...
    def resetPositions(self) -> None: ...
    def resetVelocities(self) -> None: ...
    def resetVelocity(self, index: int) -> None: ...
    def resetVelocityChanges(self) -> None: ...
    def setAcceleration(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None: ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCommand(self, index: int, command: float) -> None: ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None: ...
    def setControlForce(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None: ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None: ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setCoulombFriction(self, index: int, friction: float) -> None: ...
    def setDampingCoefficient(self, index: int, d: float) -> None: ...
    def setDofName(self, arg0_: int, arg1_: str, arg2_: bool) -> str: ...
    def setInitialPosition(self, index: int, initial: float) -> None: ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setInitialVelocity(self, index: int, initial: float) -> None: ...
    def setPosition(self, arg0_: int, arg1_: float) -> None: ...
    def setPositionLowerLimit(self, index: int, position: float) -> None: ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositionUpperLimit(self, index: int, position: float) -> None: ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setRestPosition(self, index: int, q0: float) -> None: ...
    def setSpringStiffness(self, index: int, k: float) -> None: ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocity(self, index: int, velocity: float) -> None: ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None: ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None: ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64, _Shape[m, 1]]) -> None: ...
    pass
class WeldJointProperties():
    pass
class WeldJoint(ZeroDofJoint, Joint):
    @staticmethod
    def getStaticType() -> str: ...
    def getType(self) -> str: ...
    def getWeldJointProperties(self) -> WeldJointProperties: ...
    def isCyclic(self, index: int) -> bool: ...
    def setTransformFromChildBodyNode(self, T: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    def setTransformFromParentBodyNode(self, T: nimblephysics_libs._nimblephysics.math.Isometry3) -> None: ...
    pass
class ZeroDofJointProperties():
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, properties: JointProperties) -> None: ...
    pass
