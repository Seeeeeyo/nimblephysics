"""
Bindings for Eigen geometric types.
"""
from __future__ import annotations
import numpy
import typing
__all__ = ['AdR', 'AdT', 'AngleAxis', 'BoundingBox', 'GraphFlowDiscretizer', 'Isometry3', 'MultivariateGaussian', 'ParticlePath', 'Quaternion', 'Random', 'dAdInvT', 'dAdT', 'eulerXYXToMatrix', 'eulerXYZToMatrix', 'eulerXZXToMatrix', 'eulerXZYToMatrix', 'eulerYXYToMatrix', 'eulerYXZToMatrix', 'eulerYZXToMatrix', 'eulerYZYToMatrix', 'eulerZXYToMatrix', 'eulerZXZToMatrix', 'eulerZYXToMatrix', 'eulerZYZToMatrix', 'expAngular', 'expMap', 'expMapJac', 'expMapRot', 'expToQuat', 'leftMultiplyInFreeJointSpace', 'logMap', 'matrixToEulerXYX', 'matrixToEulerXYZ', 'matrixToEulerXZY', 'matrixToEulerYXZ', 'matrixToEulerYZX', 'matrixToEulerZXY', 'matrixToEulerZYX', 'quatToExp', 'rightMultiplyInFreeJointSpace', 'transformBy', 'verifyRotation', 'verifyTransform']
class AngleAxis:
    """
    Bindings for Eigen::AngleAxis<>.
    """
    @staticmethod
    def Identity() -> AngleAxis:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, angle: float, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, quaternion: Quaternion) -> None:
        ...
    @typing.overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    @typing.overload
    def __init__(self, other: AngleAxis) -> None:
        ...
    def __str__(self) -> str:
        ...
    def angle(self) -> float:
        ...
    def axis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def inverse(self) -> AngleAxis:
        ...
    def multiply(self, arg0: AngleAxis) -> Quaternion:
        ...
    def quaternion(self) -> Quaternion:
        ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def set_angle(self, angle: float) -> None:
        ...
    def set_axis(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def set_quaternion(self, arg0: Quaternion) -> None:
        ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    def to_rotation_matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
class BoundingBox:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, min: numpy.ndarray[numpy.float64[3, 1]], max: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def computeCenter(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def computeFullExtents(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def computeHalfExtents(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getMax(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getMin(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class GraphFlowDiscretizer:
    def __init__(self, numNodes: int, arcs: list[tuple[int, int]], nodeAttachedToSink: list[bool]) -> None:
        ...
    def cleanUpArcRates(self, energyLevels: numpy.ndarray[numpy.float64[m, n]], arcRates: numpy.ndarray[numpy.float64[m, n]]) -> numpy.ndarray[numpy.float64[m, n]]:
        """
        This will find the least-squares closest rates of transfer across the arcs to end up with the energy levels at each node we got over time. The idea here is that arc rates may not perfectly reflect the observed changes in energy levels.
        """
    def discretize(self, maxSimultaneousParticles: int, energyLevels: numpy.ndarray[numpy.float64[m, n]], arcRates: numpy.ndarray[numpy.float64[m, n]]) -> list[ParticlePath]:
        """
        This will attempt to create a set of ParticlePath objects that map the recorded graph node levels and flows as closely as possible. The particles can be created and destroyed within the arcs.
        """
class Isometry3:
    @staticmethod
    def Identity() -> Isometry3:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, matrix: numpy.ndarray[numpy.float64[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3, 3]], translation: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, quaternion: Quaternion, translation: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, other: Isometry3) -> None:
        ...
    def __str__(self) -> str:
        ...
    def inverse(self) -> Isometry3:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[4, 4]]:
        ...
    @typing.overload
    def multiply(self, other: Isometry3) -> Isometry3:
        ...
    @typing.overload
    def multiply(self, position: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def pretranslate(self, other: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def quaternion(self) -> Quaternion:
        ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def set_matrix(self, arg0: numpy.ndarray[numpy.float64[4, 4]]) -> None:
        ...
    def set_quaternion(self, arg0: Quaternion) -> None:
        ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    def set_translation(self, arg0: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def translate(self, other: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def translation(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class MultivariateGaussian:
    @staticmethod
    def loadFromCSV(file: str, columns: list[str], units: float = ...) -> MultivariateGaussian:
        ...
    def __init__(self, variables: list[str], mu: numpy.ndarray[numpy.float64[m, 1]], cov: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def computeLogPDF(self, values: numpy.ndarray[numpy.float64[m, 1]], normalized: bool = ...) -> float:
        ...
    def computeLogPDFGrad(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def computePDF(self, values: numpy.ndarray[numpy.float64[m, 1]]) -> float:
        ...
    def condition(self, observedValues: dict[str, float]) -> MultivariateGaussian:
        ...
    def convertFromMap(self, values: dict[str, float]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def convertToMap(self, values: numpy.ndarray[numpy.float64[m, 1]]) -> dict[str, float]:
        ...
    def debugToStdout(self) -> None:
        ...
    def getCov(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getCovSubset(self, rowIndices: list[int], colIndices: list[int]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getLogNormalizationConstant(self) -> float:
        ...
    def getMean(self, variable: str) -> float:
        ...
    def getMu(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getMuSubset(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getObservedIndices(self, observedValues: dict[str, float]) -> list[int]:
        ...
    def getUnobservedIndices(self, observedValues: dict[str, float]) -> list[int]:
        ...
    def getVariableNameAtIndex(self, i: int) -> str:
        ...
    def getVariableNames(self) -> list[str]:
        ...
class ParticlePath:
    energyValue: float
    nodeHistory: list[int]
    startTime: int
class Quaternion:
    """
    Provides a unit quaternion binding of Eigen::Quaternion<>.
    """
    @staticmethod
    def Identity() -> Quaternion:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, wxyz: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, w: float, x: float, y: float, z: float) -> None:
        ...
    @typing.overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    @typing.overload
    def __init__(self, other: Quaternion) -> None:
        ...
    def __str__(self) -> str:
        ...
    def conjugate(self) -> Quaternion:
        ...
    def inverse(self) -> Quaternion:
        ...
    @typing.overload
    def multiply(self, arg0: Quaternion) -> Quaternion:
        ...
    @typing.overload
    def multiply(self, position: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    @typing.overload
    def set_wxyz(self, wxyz: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def set_wxyz(self, w: float, x: float, y: float, z: float) -> None:
        ...
    def to_rotation_matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def w(self) -> float:
        ...
    def wxyz(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def x(self) -> float:
        ...
    def xyz(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def y(self) -> float:
        ...
    def z(self) -> float:
        ...
class Random:
    @staticmethod
    def getSeed() -> int:
        ...
    @staticmethod
    def setSeed(seed: int) -> None:
        ...
    @staticmethod
    def uniform(min: float, max: float) -> float:
        ...
    def __init__(self) -> None:
        ...
def AdR(R: numpy.ndarray[numpy.float64[3, 3]], S: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
    ...
def AdT(R: numpy.ndarray[numpy.float64[3, 3]], p: numpy.ndarray[numpy.float64[3, 1]], S: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
    ...
def dAdInvT(R: numpy.ndarray[numpy.float64[3, 3]], p: numpy.ndarray[numpy.float64[3, 1]], S: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
    ...
def dAdT(R: numpy.ndarray[numpy.float64[3, 3]], p: numpy.ndarray[numpy.float64[3, 1]], S: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
    ...
def eulerXYXToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerXYZToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerXZXToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerXZYToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerYXYToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerYXZToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerYZXToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerYZYToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerZXYToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerZXZToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerZYXToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def eulerZYZToMatrix(angle: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def expAngular(s: numpy.ndarray[numpy.float64[3, 1]]) -> Isometry3:
    ...
def expMap(S: numpy.ndarray[numpy.float64[6, 1]]) -> Isometry3:
    ...
def expMapJac(expmap: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def expMapRot(expmap: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
    ...
def expToQuat(v: numpy.ndarray[numpy.float64[3, 1]]) -> Quaternion:
    ...
def leftMultiplyInFreeJointSpace(R: numpy.ndarray[numpy.float64[3, 3]], p: numpy.ndarray[numpy.float64[3, 1]], S: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
    ...
def logMap(S: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def matrixToEulerXYX(R: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def matrixToEulerXYZ(R: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def matrixToEulerXZY(R: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def matrixToEulerYXZ(R: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def matrixToEulerYZX(R: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def matrixToEulerZXY(R: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def matrixToEulerZYX(R: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def quatToExp(q: Quaternion) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def rightMultiplyInFreeJointSpace(R: numpy.ndarray[numpy.float64[3, 3]], p: numpy.ndarray[numpy.float64[3, 1]], S: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
    ...
def transformBy(T: Isometry3, p: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
def verifyRotation(R: numpy.ndarray[numpy.float64[3, 3]]) -> bool:
    ...
def verifyTransform(T: Isometry3) -> bool:
    ...
