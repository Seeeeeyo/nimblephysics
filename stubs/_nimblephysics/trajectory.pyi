"""
This provides a native trajectory optimization framework to DART, transcribing DART trajectory problems into IPOPT for solutions.
"""
from __future__ import annotations
import _nimblephysics.neural
import _nimblephysics.performance
import _nimblephysics.simulation
import numpy
import typing
__all__ = ['IPOptOptimizer', 'LossFn', 'MultiShot', 'OptimizationStep', 'Optimizer', 'Problem', 'SGDOptimizer', 'SingleShot', 'Solution', 'TrajectoryRollout']
class IPOptOptimizer(Optimizer):
    def __init__(self) -> None:
        ...
    def optimize(self, shot: Problem, reuseRecord: Solution = ...) -> Solution:
        ...
    def setCheckDerivatives(self, checkDerivatives: bool = ...) -> None:
        ...
    def setDisableLinesearch(self, disableLinesearch: bool = ...) -> None:
        ...
    def setIterationLimit(self, iterationLimit: int = ...) -> None:
        ...
    def setLBFGSHistoryLength(self, historyLen: int = ...) -> None:
        ...
    def setPrintFrequency(self, printFrequency: int = ...) -> None:
        ...
    def setRecordIterations(self, recordIterations: bool = ...) -> None:
        ...
    def setRecordPerformanceLog(self, recordPerfLog: bool = ...) -> None:
        ...
    def setRecoverBest(self, recoverBest: bool = ...) -> None:
        ...
    def setSilenceOutput(self, silenceOutput: bool = ...) -> None:
        ...
    def setSuppressOutput(self, suppressOutput: bool = ...) -> None:
        ...
    def setTolerance(self, tol: float = ...) -> None:
        ...
class LossFn:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, loss: typing.Callable[[_nimblephysics.trajectory.TrajectoryRollout], float]) -> None:
        ...
    @typing.overload
    def __init__(self, loss: typing.Callable[[_nimblephysics.trajectory.TrajectoryRollout], float], lossFnAndGrad: typing.Callable[[_nimblephysics.trajectory.TrajectoryRollout, _nimblephysics.trajectory.TrajectoryRollout], float]) -> None:
        ...
    def getLoss(self, rollout: TrajectoryRollout, perfLog: _nimblephysics.performance.PerformanceLog = ...) -> float:
        ...
    def getLossAndGradient(self, rollout: TrajectoryRollout, gradWrtRollout: TrajectoryRollout, perfLog: _nimblephysics.performance.PerformanceLog = ...) -> float:
        ...
    def getLowerBound(self) -> float:
        ...
    def getUpperBound(self) -> float:
        ...
    def setLowerBound(self, lowerBound: float) -> None:
        ...
    def setUpperBound(self, upperBound: float) -> None:
        ...
class MultiShot(Problem):
    def __init__(self, world: _nimblephysics.simulation.World, loss: LossFn, steps: int, shotLength: int, tuneStartingState: bool = ...) -> None:
        ...
    def setParallelOperationsEnabled(self, enabled: bool) -> None:
        ...
class OptimizationStep:
    @property
    def constraintViolation(self) -> float:
        ...
    @property
    def index(self) -> int:
        ...
    @property
    def loss(self) -> float:
        ...
    @property
    def rollout(self) -> TrajectoryRollout:
        ...
class Optimizer:
    def registerIntermediateCallback(self, callback: typing.Callable[[_nimblephysics.trajectory.Problem, int, float, float], bool]) -> None:
        ...
class Problem:
    def addConstraint(self, constraint: LossFn) -> None:
        ...
    def addMapping(self, key: str, mapping: _nimblephysics.neural.Mapping) -> None:
        ...
    def getConstraintDim(self) -> int:
        ...
    def getExploreAlternateStrategies(self) -> bool:
        ...
    def getFinalState(self, world: _nimblephysics.simulation.World, perfLog: _nimblephysics.performance.PerformanceLog = ...) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getFlatDimName(self, world: _nimblephysics.simulation.World, dim: int) -> str:
        ...
    def getFlatProblemDim(self, world: _nimblephysics.simulation.World) -> int:
        ...
    def getLoss(self, world: _nimblephysics.simulation.World, perfLog: _nimblephysics.performance.PerformanceLog = ...) -> float:
        ...
    def getMapping(self, key: str) -> _nimblephysics.neural.Mapping:
        ...
    def getMappings(self) -> dict[str, _nimblephysics.neural.Mapping]:
        ...
    def getNumSteps(self) -> int:
        ...
    def getPinnedForce(self, time: int) -> numpy.ndarray[numpy.float64[m, 1], numpy.ndarray.flags.writeable]:
        ...
    def getRepresentationStateSize(self) -> int:
        ...
    def getRolloutCache(self, world: _nimblephysics.simulation.World, perfLog: _nimblephysics.performance.PerformanceLog = ..., useKnots: bool = ...) -> TrajectoryRollout:
        ...
    def getStartState(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasMapping(self, key: str) -> bool:
        ...
    def pinForce(self, time: int, value: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def removeMapping(self, key: str) -> None:
        ...
    def setControlForcesRaw(self, forces: numpy.ndarray[numpy.float64[m, n]], perfLog: _nimblephysics.performance.PerformanceLog = ...) -> None:
        ...
    def setExploreAlternateStrategies(self, flag: bool) -> None:
        ...
    def setLoss(self, loss: LossFn) -> None:
        ...
    def setStates(self, world: _nimblephysics.simulation.World, rollout: TrajectoryRollout, perfLog: _nimblephysics.performance.PerformanceLog = ...) -> None:
        ...
    def updateWithForces(self, world: _nimblephysics.simulation.World, forces: numpy.ndarray[numpy.float64[m, n]], perfLog: _nimblephysics.performance.PerformanceLog = ...) -> numpy.ndarray[numpy.int32[m, 1]]:
        ...
class SGDOptimizer(Optimizer):
    def __init__(self) -> None:
        ...
    def optimize(self, shot: Problem, reuseRecord: Solution = ...) -> Solution:
        ...
    def setIterationLimit(self, iterationLimit: int = ...) -> None:
        ...
    def setLearningRate(self, learningRate: float = ...) -> None:
        ...
    def setTolerance(self, tol: float = ...) -> None:
        ...
class SingleShot(Problem):
    def __init__(self, world: _nimblephysics.simulation.World, loss: LossFn, steps: int, tuneStartingState: bool = ...) -> None:
        ...
class Solution:
    def getNumSteps(self) -> int:
        ...
    def getPerfLog(self) -> _nimblephysics.performance.PerformanceLog:
        ...
    def getStep(self, step: int) -> OptimizationStep:
        ...
    def reoptimize(self) -> None:
        ...
    def toJson(self, world: _nimblephysics.simulation.World) -> str:
        ...
class TrajectoryRollout:
    def copy(self) -> TrajectoryRollout:
        ...
    def getControlForces(self, mapping: str = ...) -> numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def getMappings(self) -> list[str]:
        ...
    def getMasses(self) -> numpy.ndarray[numpy.float64[m, 1], numpy.ndarray.flags.writeable]:
        ...
    def getPoses(self, mapping: str = ...) -> numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def getVels(self, mapping: str = ...) -> numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def toJson(self, world: _nimblephysics.simulation.World) -> str:
        ...
