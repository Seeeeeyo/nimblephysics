from __future__ import annotations
import _nimblephysics.collision
import _nimblephysics.dynamics
import _nimblephysics.math
import numpy
import typing
__all__ = ['BallJointConstraint', 'BoxedLcpConstraintSolver', 'BoxedLcpSolver', 'ConstrainedGroup', 'ConstraintBase', 'ConstraintInfo', 'ConstraintSolver', 'DantzigBoxedLcpSolver', 'JointConstraint', 'JointCoulombFrictionConstraint', 'JointLimitConstraint', 'LcpInputs', 'PgsBoxedLcpSolver', 'PgsBoxedLcpSolverOption', 'WeldJointConstraint']
class BallJointConstraint(JointConstraint):
    @typing.overload
    def __init__(self, body: _nimblephysics.dynamics.BodyNode, jointPos: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, body1: _nimblephysics.dynamics.BodyNode, body2: _nimblephysics.dynamics.BodyNode, jointPos: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class BoxedLcpConstraintSolver(ConstraintSolver):
    @typing.overload
    def __init__(self, timeStep: float) -> None:
        ...
    @typing.overload
    def __init__(self, timeStep: float, boxedLcpSolver: BoxedLcpSolver) -> None:
        ...
    def buildLcpInputs(self, arg0: ConstrainedGroup) -> LcpInputs:
        ...
    def getBoxedLcpSolver(self) -> BoxedLcpSolver:
        ...
    def getSecondaryBoxedLcpSolver(self) -> BoxedLcpSolver:
        ...
    def makeHyperAccurateAndVerySlow(self) -> None:
        ...
    def setBoxedLcpSolver(self, lcpSolver: BoxedLcpSolver) -> None:
        ...
    def solveLcp(self, arg0: LcpInputs, arg1: ConstrainedGroup) -> list[float]:
        ...
class BoxedLcpSolver:
    def getType(self) -> str:
        ...
    def solve(self, n: int, A: float, x: float, b: float, nub: int, lo: float, hi: float, findex: int) -> None:
        ...
class ConstrainedGroup:
    def __init__(self) -> None:
        ...
    def getConstraint(self, arg0: int) -> ConstraintBase:
        ...
    def getNumConstraints(self) -> int:
        ...
class ConstraintBase:
    @staticmethod
    def compressPath(skeleton: _nimblephysics.dynamics.Skeleton) -> _nimblephysics.dynamics.Skeleton:
        ...
    @staticmethod
    def getRootSkeletonOf(skeleton: _nimblephysics.dynamics.Skeleton) -> _nimblephysics.dynamics.Skeleton:
        ...
    def applyImpulse(self, impulse: float) -> None:
        ...
    def applyUnitImpulse(self, index: int) -> None:
        ...
    def excite(self) -> None:
        ...
    def getDimension(self) -> int:
        ...
    def getInformation(self, info: ConstraintInfo) -> None:
        ...
    def getRootSkeleton(self) -> _nimblephysics.dynamics.Skeleton:
        ...
    def getVelocityChange(self, vel: float, withCfm: bool) -> None:
        ...
    def isActive(self) -> bool:
        ...
    def isContactConstraint(self) -> bool:
        ...
    def unexcite(self) -> None:
        ...
    def uniteSkeletons(self) -> None:
        ...
    def update(self) -> None:
        ...
class ConstraintInfo:
    pass
class ConstraintSolver:
    def addConstraint(self, constraint: ConstraintBase) -> None:
        ...
    def addSkeleton(self, skeleton: _nimblephysics.dynamics.Skeleton) -> None:
        ...
    def addSkeletons(self, skeletons: list[_nimblephysics.dynamics.Skeleton]) -> None:
        ...
    def applyConstraintImpulses(self, arg0: list[ConstraintBase], arg1: list[float]) -> None:
        ...
    def buildConstrainedGroups(self) -> None:
        ...
    def clearLastCollisionResult(self) -> None:
        ...
    def enforceContactAndJointAndCustomConstraintsWithLcp(self) -> None:
        ...
    @typing.overload
    def getCollisionDetector(self) -> _nimblephysics.collision.CollisionDetector:
        ...
    @typing.overload
    def getCollisionDetector(self) -> _nimblephysics.collision.CollisionDetector:
        ...
    @typing.overload
    def getCollisionGroup(self) -> _nimblephysics.collision.CollisionGroup:
        ...
    @typing.overload
    def getCollisionGroup(self) -> _nimblephysics.collision.CollisionGroup:
        ...
    def getConstrainedGroups(self) -> list[ConstrainedGroup]:
        ...
    def getConstraints(self) -> list[ConstraintBase]:
        ...
    def getGradientEnabled(self) -> bool:
        ...
    def getTimeStep(self) -> float:
        ...
    def removeAllConstraints(self) -> None:
        ...
    def removeAllSkeletons(self) -> None:
        ...
    def removeConstraint(self, constraint: ConstraintBase) -> None:
        ...
    def removeSkeleton(self, skeleton: _nimblephysics.dynamics.Skeleton) -> None:
        ...
    def removeSkeletons(self, skeletons: list[_nimblephysics.dynamics.Skeleton]) -> None:
        ...
    def replaceEnforceContactAndJointAndCustomConstraintsFn(self, arg0: typing.Callable[[], None]) -> None:
        ...
    def setCollisionDetector(self, collisionDetector: _nimblephysics.collision.CollisionDetector) -> None:
        ...
    def setContactClippingDepth(self, arg0: float) -> None:
        ...
    def setGradientEnabled(self, arg0: bool) -> None:
        ...
    def setPenetrationCorrectionEnabled(self, arg0: bool) -> None:
        ...
    def setTimeStep(self, timeStep: float) -> None:
        ...
    def solve(self) -> None:
        ...
    def solveConstrainedGroups(self) -> None:
        ...
    def updateConstraints(self) -> None:
        ...
class DantzigBoxedLcpSolver(BoxedLcpSolver):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getType(self) -> str:
        ...
    def solve(self, n: int, A: float, x: float, b: float, nub: int, lo: float, hi: float, findex: int, earlyTermination: bool) -> bool:
        ...
class JointConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def getErrorAllowance() -> float:
        ...
    @staticmethod
    def getErrorReductionParameter() -> float:
        ...
    @staticmethod
    def getMaxErrorReductionVelocity() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    @staticmethod
    def setErrorAllowance(allowance: float) -> None:
        ...
    @staticmethod
    def setErrorReductionParameter(erp: float) -> None:
        ...
    @staticmethod
    def setMaxErrorReductionVelocity(erv: float) -> None:
        ...
class JointCoulombFrictionConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    def __init__(self, joint: _nimblephysics.dynamics.Joint) -> None:
        ...
class JointLimitConstraint(ConstraintBase):
    @staticmethod
    def getConstraintForceMixing() -> float:
        ...
    @staticmethod
    def getErrorAllowance() -> float:
        ...
    @staticmethod
    def getErrorReductionParameter() -> float:
        ...
    @staticmethod
    def getMaxErrorReductionVelocity() -> float:
        ...
    @staticmethod
    def setConstraintForceMixing(cfm: float) -> None:
        ...
    @staticmethod
    def setErrorAllowance(allowance: float) -> None:
        ...
    @staticmethod
    def setErrorReductionParameter(erp: float) -> None:
        ...
    @staticmethod
    def setMaxErrorReductionVelocity(erv: float) -> None:
        ...
    def __init__(self, joint: _nimblephysics.dynamics.Joint) -> None:
        ...
class LcpInputs:
    mA: numpy.ndarray[numpy.float64[m, n]]
    mB: numpy.ndarray[numpy.float64[m, 1]]
    mFIndex: numpy.ndarray[numpy.int32[m, 1]]
    mHi: numpy.ndarray[numpy.float64[m, 1]]
    mLo: numpy.ndarray[numpy.float64[m, 1]]
    mOffset: numpy.ndarray[numpy.int32[m, 1]]
    mW: numpy.ndarray[numpy.float64[m, 1]]
    mX: numpy.ndarray[numpy.float64[m, 1]]
class PgsBoxedLcpSolver(BoxedLcpSolver):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getOption(self) -> PgsBoxedLcpSolverOption:
        ...
    def getType(self) -> str:
        ...
    def setOption(self, option: PgsBoxedLcpSolverOption) -> None:
        ...
    def solve(self, n: int, A: float, x: float, b: float, nub: int, lo: float, hi: float, findex: int, earlyTermination: bool) -> bool:
        ...
class PgsBoxedLcpSolverOption:
    mDeltaXThreshold: float
    mEpsilonForDivision: float
    mMaxIteration: int
    mRandomizeConstraintOrder: bool
    mRelativeDeltaXTolerance: float
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int, deltaXTolerance: float) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int, deltaXTolerance: float, relativeDeltaXTolerance: float) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int, deltaXTolerance: float, relativeDeltaXTolerance: float, epsilonForDivision: float) -> None:
        ...
    @typing.overload
    def __init__(self, maxIteration: int, deltaXTolerance: float, relativeDeltaXTolerance: float, epsilonForDivision: float, randomizeConstraintOrder: bool) -> None:
        ...
class WeldJointConstraint(JointConstraint):
    @typing.overload
    def __init__(self, body: _nimblephysics.dynamics.BodyNode) -> None:
        ...
    @typing.overload
    def __init__(self, body1: _nimblephysics.dynamics.BodyNode, body2: _nimblephysics.dynamics.BodyNode) -> None:
        ...
    def setRelativeTransform(self, tf: _nimblephysics.math.Isometry3) -> None:
        ...
