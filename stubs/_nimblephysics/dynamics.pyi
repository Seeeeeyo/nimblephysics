from __future__ import annotations
import _nimblephysics.common
import _nimblephysics.math
import _nimblephysics.neural
import numpy
import typing
__all__ = ['ArrowShape', 'ArrowShapeProperties', 'AxisOrder', 'BallJoint', 'BallJointProperties', 'BodyNode', 'BodyNodeAspectProperties', 'BodyNodeProperties', 'BodyScaleGroup', 'BoxShape', 'CapsuleShape', 'CollisionAspect', 'CollisionAspectProperties', 'CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space', 'CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space', 'CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space', 'CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space', 'CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space', 'CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space', 'CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_R4GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_R6GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint', 'CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint', 'ConeShape', 'ContactEnergyTransmitter', 'ContactInverseDynamicsResult', 'CustomJoint1', 'CustomJoint2', 'CylinderShape', 'DataVariance', 'DegreeOfFreedom', 'Detachable', 'DynamicsAspect', 'DynamicsAspectProperties', 'EllipsoidShape', 'EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space', 'EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space', 'EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space', 'EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space', 'EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space', 'EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space', 'EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space', 'EmbedProperties_EulerJoint_EulerJointUniqueProperties', 'EmbedProperties_PlanarJoint_PlanarJointUniqueProperties', 'EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties', 'EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties', 'EmbedProperties_ScrewJoint_ScrewJointUniqueProperties', 'EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties', 'EmbedProperties_UniversalJoint_UniversalJointUniqueProperties', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint', 'EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties', 'EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties', 'EnergyAccountingFrame', 'Entity', 'EulerFreeJoint', 'EulerJoint', 'EulerJointProperties', 'EulerJointUniqueProperties', 'Frame', 'FreeJoint', 'FreeJointProperties', 'GenericJointProperties_R1', 'GenericJointProperties_R2', 'GenericJointProperties_R3', 'GenericJointProperties_R4', 'GenericJointProperties_R6', 'GenericJointProperties_SE3', 'GenericJointProperties_SO3', 'GenericJointUniqueProperties_R1', 'GenericJointUniqueProperties_R2', 'GenericJointUniqueProperties_R3', 'GenericJointUniqueProperties_R4', 'GenericJointUniqueProperties_R6', 'GenericJointUniqueProperties_SE3', 'GenericJointUniqueProperties_SO3', 'GenericJoint_R1', 'GenericJoint_R2', 'GenericJoint_R3', 'GenericJoint_R4', 'GenericJoint_R6', 'GenericJoint_SE3', 'GenericJoint_SO3', 'Inertia', 'JacobianNode', 'Joint', 'JointEnergyTransmitter', 'JointProperties', 'LineSegmentShape', 'MeshShape', 'MetaSkeleton', 'MultiSphereConvexHullShape', 'MultipleContactInverseDynamicsOverTimeResult', 'MultipleContactInverseDynamicsResult', 'Node', 'NodeProperties', 'NodeState', 'PlanarJoint', 'PlanarJointProperties', 'PlanarJointUniqueProperties', 'PlaneShape', 'PlaneType', 'PrismaticJoint', 'PrismaticJointProperties', 'PrismaticJointUniqueProperties', 'ReferentialSkeleton', 'RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties', 'RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties', 'RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties', 'RevoluteJoint', 'RevoluteJointProperties', 'RevoluteJointUniqueProperties', 'ScapulothoracicJoint', 'ScrewJoint', 'ScrewJointProperties', 'ScrewJointUniqueProperties', 'Shape', 'ShapeFrame', 'ShapeFrameProperties', 'ShapeNode', 'ShapeNodeProperties', 'SharedMeshWrapper', 'SimpleFrame', 'Skeleton', 'SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties', 'SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties', 'SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties', 'SphereShape', 'TemplatedJacobianBodyNode', 'TranslationalJoint', 'TranslationalJoint2D', 'TranslationalJoint2DProperties', 'TranslationalJoint2DUniqueProperties', 'TranslationalJointProperties', 'UniversalJoint', 'UniversalJointProperties', 'UniversalJointUniqueProperties', 'VisualAspect', 'VisualAspectProperties', 'WeldJoint', 'WeldJointProperties', 'ZeroDofJoint', 'ZeroDofJointProperties']
class ArrowShape(MeshShape):
    @typing.overload
    def __init__(self, tail: numpy.ndarray[numpy.float64[3, 1]], head: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[numpy.float64[3, 1]], head: numpy.ndarray[numpy.float64[3, 1]], properties: ArrowShapeProperties) -> None:
        ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[numpy.float64[3, 1]], head: numpy.ndarray[numpy.float64[3, 1]], properties: ArrowShapeProperties, color: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, tail: numpy.ndarray[numpy.float64[3, 1]], head: numpy.ndarray[numpy.float64[3, 1]], properties: ArrowShapeProperties, color: numpy.ndarray[numpy.float64[4, 1]], resolution: int) -> None:
        ...
    def configureArrow(self, tail: numpy.ndarray[numpy.float64[3, 1]], head: numpy.ndarray[numpy.float64[3, 1]], properties: ArrowShapeProperties) -> None:
        ...
    def getHead(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getProperties(self) -> ArrowShapeProperties:
        ...
    def getTail(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def notifyColorUpdated(self, color: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    def setPositions(self, tail: numpy.ndarray[numpy.float64[3, 1]], head: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setProperties(self, properties: ArrowShapeProperties) -> None:
        ...
class ArrowShapeProperties:
    mHeadLengthScale: float
    mHeadRadiusScale: float
    mMaxHeadLength: float
    mMinHeadLength: float
    mRadius: float
    ms_tArrow: bool
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, radius: float) -> None:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float) -> None:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float) -> None:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float) -> None:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float, maxHeadLength: float) -> None:
        ...
    @typing.overload
    def __init__(self, radius: float, headRadiusScale: float, headLengthScale: float, minHeadLength: float, maxHeadLength: float, s_tArrow: bool) -> None:
        ...
class AxisOrder:
    """
    Members:
    
      XYZ
    
      XZY
    
      ZYX
    
      ZXY
    """
    XYZ: typing.ClassVar[AxisOrder]  # value = <AxisOrder.XYZ: 1>
    XZY: typing.ClassVar[AxisOrder]  # value = <AxisOrder.XZY: 3>
    ZXY: typing.ClassVar[AxisOrder]  # value = <AxisOrder.ZXY: 2>
    ZYX: typing.ClassVar[AxisOrder]  # value = <AxisOrder.ZYX: 0>
    __members__: typing.ClassVar[dict[str, AxisOrder]]  # value = {'XYZ': <AxisOrder.XYZ: 1>, 'XZY': <AxisOrder.XZY: 3>, 'ZYX': <AxisOrder.ZYX: 0>, 'ZXY': <AxisOrder.ZXY: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class BallJoint(GenericJoint_SO3):
    @staticmethod
    def convertToRotation(positions: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def convertToTransform(positions: numpy.ndarray[numpy.float64[3, 1]]) -> _nimblephysics.math.Isometry3:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def getBallJointProperties(self) -> BallJointProperties:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[3, 1]], q1: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, 3]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
class BallJointProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, properties: BallJointProperties) -> None:
        ...
class BodyNode(TemplatedJacobianBodyNode, Frame):
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]], isImpulseLocal: bool) -> None:
        ...
    @typing.overload
    def addConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]], isImpulseLocal: bool, isOffsetLocal: bool) -> None:
        ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]], isForceLocal: bool) -> None:
        ...
    @typing.overload
    def addExtForce(self, force: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]], isForceLocal: bool, isOffsetLocal: bool) -> None:
        ...
    @typing.overload
    def addExtTorque(self, torque: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def addExtTorque(self, torque: numpy.ndarray[numpy.float64[3, 1]], isLocal: bool) -> None:
        ...
    def clearConstraintImpulse(self) -> None:
        ...
    def clearExternalForces(self) -> None:
        ...
    def clearInternalForces(self) -> None:
        ...
    def computeKineticEnergy(self) -> float:
        ...
    def computeLagrangian(self, gravity: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    def computePotentialEnergy(self, gravity: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def copy(self, otherBodyNode: BodyNode) -> None:
        ...
    @typing.overload
    def copy(self, otherBodyNode: BodyNode) -> None:
        ...
    @typing.overload
    def copyAs(self, skeletonName: str) -> Skeleton:
        ...
    @typing.overload
    def copyAs(self, skeletonName: str, recursive: bool) -> Skeleton:
        ...
    @typing.overload
    def copyTo(self, newParent: BodyNode) -> tuple[Joint, BodyNode]:
        ...
    @typing.overload
    def copyTo(self, newParent: BodyNode, recursive: bool) -> tuple[Joint, BodyNode]:
        ...
    @typing.overload
    def copyTo(self, newSkeleton: Skeleton, newParent: BodyNode) -> tuple[Joint, BodyNode]:
        ...
    @typing.overload
    def copyTo(self, newSkeleton: Skeleton, newParent: BodyNode, recursive: bool) -> tuple[Joint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, jointProperties: BallJointProperties) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, jointProperties: BallJointProperties, bodyProperties: BodyNodeProperties) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, jointProperties: EulerJointProperties) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, jointProperties: EulerJointProperties, bodyProperties: BodyNodeProperties) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, jointProperties: FreeJointProperties) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, jointProperties: FreeJointProperties, bodyProperties: BodyNodeProperties) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, jointProperties: PlanarJointProperties) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, jointProperties: PlanarJointProperties, bodyProperties: BodyNodeProperties) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, jointProperties: PrismaticJointProperties) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, jointProperties: PrismaticJointProperties, bodyProperties: BodyNodeProperties) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, jointProperties: RevoluteJointProperties) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, jointProperties: RevoluteJointProperties, bodyProperties: BodyNodeProperties) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, jointProperties: ScrewJointProperties) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, jointProperties: ScrewJointProperties, bodyProperties: BodyNodeProperties) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createShapeNode(self, shape: Shape) -> ShapeNode:
        ...
    @typing.overload
    def createShapeNode(self, shape: Shape, name: str) -> ShapeNode:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, jointProperties: TranslationalJoint2DProperties) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, jointProperties: TranslationalJoint2DProperties, bodyProperties: BodyNodeProperties) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, jointProperties: TranslationalJointProperties) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, jointProperties: TranslationalJointProperties, bodyProperties: BodyNodeProperties) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, jointProperties: UniversalJointProperties) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, jointProperties: UniversalJointProperties, bodyProperties: BodyNodeProperties) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self) -> tuple[WeldJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, jointProperties: WeldJointProperties) -> tuple[WeldJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, jointProperties: WeldJointProperties, bodyProperties: BodyNodeProperties) -> tuple[WeldJoint, BodyNode]:
        ...
    def dependsOn(self, genCoordIndex: int) -> bool:
        ...
    def dirtyAcceleration(self) -> None:
        ...
    def dirtyArticulatedInertia(self) -> None:
        ...
    def dirtyCoriolisForces(self) -> None:
        ...
    def dirtyExternalForces(self) -> None:
        ...
    def dirtyTransform(self) -> None:
        ...
    def dirtyVelocity(self) -> None:
        ...
    def duplicateNodes(self, otherBodyNode: BodyNode) -> None:
        ...
    @typing.overload
    def getAngularMomentum(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getAngularMomentum(self, pivot: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getBodyNodeProperties(self) -> BodyNodeProperties:
        ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getChildJoint(self, index: int) -> Joint:
        ...
    def getClosestVerticesToMarker(self, marker: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getConstraintImpulse(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getDependentGenCoordIndex(self, arrayIndex: int) -> int:
        ...
    def getDistToClosestVerticesToMarker(self, marker: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    def getExternalForceGlobal(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getExternalForceLocal(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getFrictionCoeff(self) -> float:
        ...
    def getGradientOfDistToClosestVerticesToMarkerWrtBodyScale(self, marker: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getGradientOfDistToClosestVerticesToMarkerWrtMarker(self, marker: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getGravityMode(self) -> bool:
        ...
    def getIndexInSkeleton(self) -> int:
        ...
    def getIndexInTree(self) -> int:
        ...
    def getLinearMomentum(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getLocalCOM(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getMass(self) -> float:
        ...
    def getMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None:
        ...
    def getName(self) -> str:
        ...
    def getNumChildBodyNodes(self) -> int:
        ...
    def getNumChildJoints(self) -> int:
        ...
    def getNumDependentDofs(self) -> int:
        ...
    def getNumDependentGenCoords(self) -> int:
        ...
    def getNumEndEffectors(self) -> int:
        ...
    def getNumMarkers(self) -> int:
        ...
    def getNumShapeNodes(self) -> int:
        ...
    def getParentBodyNode(self) -> BodyNode:
        ...
    def getParentJoint(self) -> Joint:
        ...
    def getRestitutionCoeff(self) -> float:
        ...
    def getScale(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getScaleLowerBound(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getScaleUpperBound(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getShapeNode(self, index: int) -> ShapeNode:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    def getTreeIndex(self) -> int:
        ...
    def isCollidable(self) -> bool:
        ...
    def isReactive(self) -> bool:
        ...
    def matchNodes(self, otherBodyNode: BodyNode) -> None:
        ...
    @typing.overload
    def moveTo(self, newParent: BodyNode) -> bool:
        ...
    @typing.overload
    def moveTo(self, newSkeleton: Skeleton, newParent: BodyNode) -> bool:
        ...
    @typing.overload
    def remove(self) -> Skeleton:
        ...
    @typing.overload
    def remove(self, name: str) -> Skeleton:
        ...
    def removeAllShapeNodes(self) -> None:
        ...
    def setCollidable(self, isCollidable: bool) -> None:
        ...
    def setConstraintImpulse(self, constImp: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]], isForceLocal: bool) -> None:
        ...
    @typing.overload
    def setExtForce(self, force: numpy.ndarray[numpy.float64[3, 1]], offset: numpy.ndarray[numpy.float64[3, 1]], isForceLocal: bool, isOffsetLocal: bool) -> None:
        ...
    @typing.overload
    def setExtTorque(self, torque: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setExtTorque(self, torque: numpy.ndarray[numpy.float64[3, 1]], isLocal: bool) -> None:
        ...
    def setExtWrench(self, wrench: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    def setFrictionCoeff(self, coeff: float) -> None:
        ...
    def setGravityMode(self, gravityMode: bool) -> None:
        ...
    def setInertia(self, inertia: Inertia) -> None:
        ...
    def setLocalCOM(self, com: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setMass(self, mass: float) -> None:
        ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float) -> None:
        ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float) -> None:
        ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float) -> None:
        ...
    @typing.overload
    def setMomentOfInertia(self, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -> None:
        ...
    def setName(self, name: str) -> None:
        ...
    def setRestitutionCoeff(self, coeff: float) -> None:
        ...
    def setScale(self, scale: numpy.ndarray[numpy.float64[3, 1]], silentlyClamp: bool = ...) -> None:
        ...
    def setScaleLowerBound(self, scale: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setScaleUpperBound(self, scale: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def split(self, skeletonName: str) -> Skeleton:
        ...
class BodyNodeAspectProperties:
    mFrictionCoeff: float
    mGravityMode: bool
    mInertia: Inertia
    mIsCollidable: bool
    mName: str
    mRestitutionCoeff: float
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, name: str) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia, isCollidable: bool) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia, isCollidable: bool, frictionCoeff: float) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia, isCollidable: bool, frictionCoeff: float, restitutionCoeff: float) -> None:
        ...
    @typing.overload
    def __init__(self, name: str, inertia: Inertia, isCollidable: bool, frictionCoeff: float, restitutionCoeff: float, gravityMode: bool) -> None:
        ...
class BodyNodeProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, aspectProperties: BodyNodeAspectProperties) -> None:
        ...
class BodyScaleGroup:
    flipAxis: list[numpy.ndarray[numpy.float64[3, 1]]]
    nodes: list[BodyNode]
    uniformScaling: bool
class BoxShape(Shape):
    @staticmethod
    def computeInertiaOf(size: numpy.ndarray[numpy.float64[3, 1]], mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def computeVolume(size: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, size: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getSize(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getType(self) -> str:
        ...
    def setSize(self, size: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class CapsuleShape(Shape):
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def computeVolumeOf(radius: float, height: float) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, radius: float, height: float) -> None:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getHeight(self) -> float:
        ...
    def getRadius(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setHeight(self, height: float) -> None:
        ...
    def setRadius(self, radius: float) -> None:
        ...
class CollisionAspect:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, properties: CollisionAspectProperties) -> None:
        ...
    def getCollidable(self) -> bool:
        ...
    def isCollidable(self) -> bool:
        ...
    def setCollidable(self, value: bool) -> None:
        ...
class CollisionAspectProperties:
    pass
class CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space(EmbedProperties_EulerJoint_EulerJointUniqueProperties, GenericJoint_R3):
    pass
class CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space(EmbedProperties_PlanarJoint_PlanarJointUniqueProperties, GenericJoint_R3):
    pass
class CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties, GenericJoint_R1):
    pass
class CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties, GenericJoint_R1):
    pass
class CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space(EmbedProperties_ScrewJoint_ScrewJointUniqueProperties, GenericJoint_R1):
    pass
class CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space(EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties, GenericJoint_R2):
    pass
class CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space(EmbedProperties_UniversalJoint_UniversalJointUniqueProperties, GenericJoint_R2):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R4GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_R6GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint(EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties, Joint):
    pass
class ConeShape(Shape):
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def computeVolume(radius: float, height: float) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, radius: float, height: float) -> None:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getHeight(self) -> float:
        ...
    def getRadius(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setHeight(self, height: float) -> None:
        ...
    def setRadius(self, radius: float) -> None:
        ...
class ContactEnergyTransmitter:
    contactBody: str
    contactBodyCenter: numpy.ndarray[numpy.float64[3, 1]]
    powerToBody: float
    worldCenter: numpy.ndarray[numpy.float64[3, 1]]
    worldForce: numpy.ndarray[numpy.float64[3, 1]]
    worldMoment: numpy.ndarray[numpy.float64[3, 1]]
    def __init__(self) -> None:
        ...
class ContactInverseDynamicsResult:
    acc: numpy.ndarray[numpy.float64[m, 1]]
    contactBody: BodyNode
    contactWrench: numpy.ndarray[numpy.float64[6, 1]]
    jointTorques: numpy.ndarray[numpy.float64[m, 1]]
    pos: numpy.ndarray[numpy.float64[m, 1]]
    skel: Skeleton
    vel: numpy.ndarray[numpy.float64[m, 1]]
    def __init__(self) -> None:
        ...
    def sumError(self) -> float:
        ...
class CustomJoint1(GenericJoint_R1):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getAxisOrder(self) -> AxisOrder:
        ...
    def getCustomFunctionGradientAt(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getCustomFunctionPositions(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCustomFunctionSecondGradientAt(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[1, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None:
        ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class CustomJoint2(GenericJoint_R2):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getAxisOrder(self) -> AxisOrder:
        ...
    def getCustomFunctionGradientAt(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getCustomFunctionPositions(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCustomFunctionSecondGradientAt(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[6, 2]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None:
        ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class CylinderShape(Shape):
    @staticmethod
    def computeInertiaOf(radius: float, height: float, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def computeVolumeOf(radius: float, height: float) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, radius: float, height: float) -> None:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getHeight(self) -> float:
        ...
    def getRadius(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setHeight(self, height: float) -> None:
        ...
    def setRadius(self, radius: float) -> None:
        ...
class DataVariance:
    """
    Members:
    
      STATIC
    
      DYNAMIC_PRIMITIVE
    
      DYNAMIC_COLOR
    
      DYNAMIC_VERTICES
    
      DYNAMIC_ELEMENTS
    
      DYNAMIC
    
      DYNAMIC_TRANSFORM
    """
    DYNAMIC: typing.ClassVar[DataVariance]  # value = <DataVariance.DYNAMIC: 255>
    DYNAMIC_COLOR: typing.ClassVar[DataVariance]  # value = <DataVariance.DYNAMIC_COLOR: 8>
    DYNAMIC_ELEMENTS: typing.ClassVar[DataVariance]  # value = <DataVariance.DYNAMIC_ELEMENTS: 32>
    DYNAMIC_PRIMITIVE: typing.ClassVar[DataVariance]  # value = <DataVariance.DYNAMIC_PRIMITIVE: 4>
    DYNAMIC_TRANSFORM: typing.ClassVar[DataVariance]  # value = <DataVariance.DYNAMIC_TRANSFORM: 2>
    DYNAMIC_VERTICES: typing.ClassVar[DataVariance]  # value = <DataVariance.DYNAMIC_VERTICES: 16>
    STATIC: typing.ClassVar[DataVariance]  # value = <DataVariance.STATIC: 0>
    __members__: typing.ClassVar[dict[str, DataVariance]]  # value = {'STATIC': <DataVariance.STATIC: 0>, 'DYNAMIC_PRIMITIVE': <DataVariance.DYNAMIC_PRIMITIVE: 4>, 'DYNAMIC_COLOR': <DataVariance.DYNAMIC_COLOR: 8>, 'DYNAMIC_VERTICES': <DataVariance.DYNAMIC_VERTICES: 16>, 'DYNAMIC_ELEMENTS': <DataVariance.DYNAMIC_ELEMENTS: 32>, 'DYNAMIC': <DataVariance.DYNAMIC: 255>, 'DYNAMIC_TRANSFORM': <DataVariance.DYNAMIC_TRANSFORM: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class DegreeOfFreedom:
    def getAcceleration(self) -> float:
        ...
    def getAccelerationLimits(self) -> tuple[float, float]:
        ...
    def getAccelerationLowerLimit(self) -> float:
        ...
    def getAccelerationUpperLimit(self) -> float:
        ...
    def getCommand(self) -> float:
        ...
    def getConstraintImpulse(self) -> float:
        ...
    def getControlForce(self) -> float:
        ...
    def getControlForceLimits(self) -> tuple[float, float]:
        ...
    def getControlForceLowerLimit(self) -> float:
        ...
    def getControlForceUpperLimit(self) -> float:
        ...
    def getCoulombFriction(self) -> float:
        ...
    def getDampingCoefficient(self) -> float:
        ...
    def getIndexInJoint(self) -> int:
        ...
    def getIndexInSkeleton(self) -> int:
        ...
    def getIndexInTree(self) -> int:
        ...
    def getInitialPosition(self) -> float:
        ...
    def getInitialVelocity(self) -> float:
        ...
    def getJointName(self) -> str:
        ...
    def getName(self) -> str:
        ...
    def getPosition(self) -> float:
        ...
    def getPositionLimits(self) -> tuple[float, float]:
        ...
    @typing.overload
    def getPositionLowerLimit(self) -> float:
        ...
    @typing.overload
    def getPositionLowerLimit(self) -> float:
        ...
    @typing.overload
    def getPositionUpperLimit(self) -> float:
        ...
    @typing.overload
    def getPositionUpperLimit(self) -> float:
        ...
    def getRestPosition(self) -> float:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    def getSpringStiffness(self) -> float:
        ...
    def getTreeIndex(self) -> int:
        ...
    def getVelocity(self) -> float:
        ...
    def getVelocityChange(self) -> float:
        ...
    def getVelocityLimits(self) -> tuple[float, float]:
        ...
    def getVelocityLowerLimit(self) -> float:
        ...
    def getVelocityUpperLimit(self) -> float:
        ...
    def hasPositionLimit(self) -> bool:
        ...
    def isCyclic(self) -> bool:
        ...
    def isNamePreserved(self) -> bool:
        ...
    def preserveName(self, preserve: bool) -> None:
        ...
    def resetAcceleration(self) -> None:
        ...
    def resetCommand(self) -> None:
        ...
    def resetConstraintImpulse(self) -> None:
        ...
    def resetControlForce(self) -> None:
        ...
    def resetPosition(self) -> None:
        ...
    def resetVelocity(self) -> None:
        ...
    def resetVelocityChange(self) -> None:
        ...
    def setAcceleration(self, acceleration: float) -> None:
        ...
    @typing.overload
    def setAccelerationLimits(self, lowerLimit: float, upperLimit: float) -> None:
        ...
    @typing.overload
    def setAccelerationLimits(self, limits: tuple[float, float]) -> None:
        ...
    def setAccelerationLowerLimit(self, limit: float) -> None:
        ...
    def setAccelerationUpperLimit(self, limit: float) -> None:
        ...
    def setCommand(self, command: float) -> None:
        ...
    def setConstraintImpulse(self, impulse: float) -> None:
        ...
    def setControlForce(self, force: float) -> None:
        ...
    @typing.overload
    def setControlForceLimits(self, lowerLimit: float, upperLimit: float) -> None:
        ...
    @typing.overload
    def setControlForceLimits(self, limits: tuple[float, float]) -> None:
        ...
    def setControlForceLowerLimit(self, limit: float) -> None:
        ...
    def setControlForceUpperLimit(self, limit: float) -> None:
        ...
    def setCoulombFriction(self, friction: float) -> None:
        ...
    def setDampingCoefficient(self, coeff: float) -> None:
        ...
    def setInitialPosition(self, initial: float) -> None:
        ...
    def setInitialVelocity(self, initial: float) -> None:
        ...
    @typing.overload
    def setName(self, name: str) -> str:
        ...
    @typing.overload
    def setName(self, name: str, preserveName: bool) -> str:
        ...
    def setPosition(self, position: float) -> None:
        ...
    @typing.overload
    def setPositionLimits(self, lowerLimit: float, upperLimit: float) -> None:
        ...
    @typing.overload
    def setPositionLimits(self, limits: tuple[float, float]) -> None:
        ...
    @typing.overload
    def setPositionLowerLimit(self, limit: float) -> None:
        ...
    @typing.overload
    def setPositionLowerLimit(self, limit: float) -> None:
        ...
    @typing.overload
    def setPositionUpperLimit(self, limit: float) -> None:
        ...
    @typing.overload
    def setPositionUpperLimit(self, limit: float) -> None:
        ...
    def setRestPosition(self, q0: float) -> None:
        ...
    def setSpringStiffness(self, k: float) -> None:
        ...
    def setVelocity(self, velocity: float) -> None:
        ...
    def setVelocityChange(self, velocityChange: float) -> None:
        ...
    @typing.overload
    def setVelocityLimits(self, lowerLimit: float, upperLimit: float) -> None:
        ...
    @typing.overload
    def setVelocityLimits(self, limits: tuple[float, float]) -> None:
        ...
    def setVelocityLowerLimit(self, limit: float) -> None:
        ...
    def setVelocityUpperLimit(self, limit: float) -> None:
        ...
class Detachable(Entity):
    def setParentFrame(self, newParentFrame: Frame) -> None:
        ...
class DynamicsAspect:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, properties: DynamicsAspectProperties) -> None:
        ...
    def getFrictionCoeff(self) -> float:
        ...
    def getRestitutionCoeff(self) -> float:
        ...
    def setFrictionCoeff(self, value: float) -> None:
        ...
    def setRestitutionCoeff(self, value: float) -> None:
        ...
class DynamicsAspectProperties:
    pass
class EllipsoidShape(Shape):
    @staticmethod
    def computeInertiaOf(diameters: numpy.ndarray[numpy.float64[3, 1]], mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def computeVolumeOf(diameters: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, diameters: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getDiameters(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRadii(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getType(self) -> str:
        ...
    def isSphere(self) -> bool:
        ...
    def setDiameters(self, diameters: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setRadii(self, radii: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space(CompositeJoiner_EmbedProperties_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space):
    pass
class EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space(CompositeJoiner_EmbedProperties_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space):
    pass
class EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space):
    pass
class EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space):
    pass
class EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space(CompositeJoiner_EmbedProperties_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space):
    pass
class EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space(CompositeJoiner_EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space):
    pass
class EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space(CompositeJoiner_EmbedProperties_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space):
    pass
class EmbedProperties_EulerJoint_EulerJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties):
    pass
class EmbedProperties_PlanarJoint_PlanarJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties):
    pass
class EmbedProperties_PrismaticJoint_PrismaticJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties):
    pass
class EmbedProperties_RevoluteJoint_RevoluteJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties):
    pass
class EmbedProperties_ScrewJoint_ScrewJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties):
    pass
class EmbedProperties_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties):
    pass
class EmbedProperties_UniversalJoint_UniversalJointUniqueProperties(RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R1GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R2GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R3GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R4GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_R6GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_SE3GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint(CompositeJoiner_EmbedStateAndProperties_GenericJoint_SO3GenericJointStateGenericJointUniqueProperties_Joint):
    pass
class EmbedStateAndProperties_GenericJoint_R1GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_R2GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_R3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_R4GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_R6GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_SE3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties):
    pass
class EmbedStateAndProperties_GenericJoint_SO3GenericJointState_GenericJointUniqueProperties(RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties):
    pass
class EnergyAccountingFrame:
    bodyCenters: list[numpy.ndarray[numpy.float64[3, 1]]]
    bodyChildJointPowerSum: numpy.ndarray[numpy.float64[m, 1]]
    bodyChildJointPowers: list[list[float]]
    bodyExternalForcePower: numpy.ndarray[numpy.float64[m, 1]]
    bodyGravityPower: numpy.ndarray[numpy.float64[m, 1]]
    bodyKineticEnergy: numpy.ndarray[numpy.float64[m, 1]]
    bodyKineticEnergyDeriv: numpy.ndarray[numpy.float64[m, 1]]
    bodyParentJointPower: numpy.ndarray[numpy.float64[m, 1]]
    bodyPotentialEnergy: numpy.ndarray[numpy.float64[m, 1]]
    bodyPotentialEnergyDeriv: numpy.ndarray[numpy.float64[m, 1]]
    contacts: list[ContactEnergyTransmitter]
    joints: list[JointEnergyTransmitter]
    def __init__(self) -> None:
        ...
class Entity:
    def descendsFrom(self, someFrame: Frame) -> bool:
        ...
    def dirtyAcceleration(self) -> None:
        ...
    def dirtyTransform(self) -> None:
        ...
    def dirtyVelocity(self) -> None:
        ...
    def getName(self) -> str:
        ...
    def getParentFrame(self) -> Frame:
        ...
    def isFrame(self) -> bool:
        ...
    def isQuiet(self) -> bool:
        ...
    def needsAccelerationUpdate(self) -> bool:
        ...
    def needsTransformUpdate(self) -> bool:
        ...
    def needsVelocityUpdate(self) -> bool:
        ...
    def setName(self, name: str) -> str:
        ...
class EulerFreeJoint(GenericJoint_R6):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getAxisOrder(self) -> AxisOrder:
        ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None:
        ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class EulerJoint(EmbedPropertiesOnTopOf_EulerJoint_EulerJointUniqueProperties_GenericJoint_R3Space):
    @staticmethod
    def convertToRotationOf(positions: numpy.ndarray[numpy.float64[3, 1]], ordering: AxisOrder, flipAxisMap: numpy.ndarray[numpy.float64[3, 1]] = ...) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def convertToTransformOf(positions: numpy.ndarray[numpy.float64[3, 1]], ordering: AxisOrder, flipAxisMap: numpy.ndarray[numpy.float64[3, 1]] = ...) -> _nimblephysics.math.Isometry3:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def convertToRotation(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def convertToTransform(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> _nimblephysics.math.Isometry3:
        ...
    def copy(self, otherJoint: EulerJoint) -> None:
        ...
    def getAxisOrder(self) -> AxisOrder:
        ...
    def getEulerJointProperties(self) -> EulerJointProperties:
        ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, 3]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    @typing.overload
    def setAxisOrder(self, order: AxisOrder) -> None:
        ...
    @typing.overload
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None:
        ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: EulerJointProperties) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: EulerJointUniqueProperties) -> None:
        ...
class EulerJointProperties(EulerJointUniqueProperties):
    mAxisOrder: AxisOrder
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: EulerJointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: EulerJointProperties, uniqueProperties: EulerJointUniqueProperties) -> None:
        ...
class EulerJointUniqueProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, axisOrder: AxisOrder) -> None:
        ...
class Frame(Entity):
    @staticmethod
    def World() -> Frame:
        ...
    def dirtyAcceleration(self) -> None:
        ...
    def dirtyTransform(self) -> None:
        ...
    def dirtyVelocity(self) -> None:
        ...
    @typing.overload
    def getAngularAcceleration(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getAngularAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getAngularAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getAngularVelocity(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getAngularVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getAngularVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getChildEntities(self) -> set[Entity]:
        ...
    def getChildFrames(self) -> set[Frame]:
        ...
    @typing.overload
    def getLinearAcceleration(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearAcceleration(self, offset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearVelocity(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getLinearVelocity(self, offset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getNumChildEntities(self) -> int:
        ...
    def getNumChildFrames(self) -> int:
        ...
    def getRelativeTransform(self) -> _nimblephysics.math.Isometry3:
        ...
    @typing.overload
    def getSpatialAcceleration(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getSpatialAcceleration(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getSpatialAcceleration(self, offset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getSpatialVelocity(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getSpatialVelocity(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getSpatialVelocity(self, offset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getTransform(self) -> _nimblephysics.math.Isometry3:
        ...
    @typing.overload
    def getTransform(self, withRespectTo: Frame) -> _nimblephysics.math.Isometry3:
        ...
    @typing.overload
    def getTransform(self, withRespectTo: Frame, inCoordinatesOf: Frame) -> _nimblephysics.math.Isometry3:
        ...
    def getWorldTransform(self) -> _nimblephysics.math.Isometry3:
        ...
    def isShapeFrame(self) -> bool:
        ...
    def isWorld(self) -> bool:
        ...
class FreeJoint(GenericJoint_SE3):
    @staticmethod
    def convertToPositions(tf: _nimblephysics.math.Isometry3) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @staticmethod
    def convertToTransform(positions: numpy.ndarray[numpy.float64[6, 1]]) -> _nimblephysics.math.Isometry3:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(joint: Joint, tf: _nimblephysics.math.Isometry3) -> None:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(joint: Joint, tf: _nimblephysics.math.Isometry3, withRespectTo: Frame) -> None:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(bodyNode: BodyNode, tf: _nimblephysics.math.Isometry3) -> None:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(bodyNode: BodyNode, tf: _nimblephysics.math.Isometry3, withRespectTo: Frame) -> None:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: Skeleton, tf: _nimblephysics.math.Isometry3) -> None:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: Skeleton, tf: _nimblephysics.math.Isometry3, withRespectTo: Frame) -> None:
        ...
    @staticmethod
    @typing.overload
    def setTransformOf(skeleton: Skeleton, tf: _nimblephysics.math.Isometry3, withRespectTo: Frame, applyToAllRootBodies: bool) -> None:
        ...
    def getFreeJointProperties(self) -> FreeJointProperties:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[6, 1]], q1: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame) -> None:
        ...
    @typing.overload
    def setAngularAcceleration(self, newAngularAcceleration: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None:
        ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame) -> None:
        ...
    @typing.overload
    def setAngularVelocity(self, newAngularVelocity: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None:
        ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame) -> None:
        ...
    @typing.overload
    def setLinearAcceleration(self, newLinearAcceleration: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None:
        ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame) -> None:
        ...
    @typing.overload
    def setLinearVelocity(self, newLinearVelocity: numpy.ndarray[numpy.float64[3, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None:
        ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64[6, 1]], inCoordinatesOf: Frame) -> None:
        ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64[6, 1]], inCoordinatesOf: Frame) -> None:
        ...
    def setRelativeTransform(self, newTransform: _nimblephysics.math.Isometry3) -> None:
        ...
    def setSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64[6, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None:
        ...
    def setSpatialMotion(self, newTransform: _nimblephysics.math.Isometry3, withRespectTo: Frame, newSpatialVelocity: numpy.ndarray[numpy.float64[6, 1]], velRelativeTo: Frame, velInCoordinatesOf: Frame, newSpatialAcceleration: numpy.ndarray[numpy.float64[6, 1]], accRelativeTo: Frame, accInCoordinatesOf: Frame) -> None:
        ...
    def setSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64[6, 1]], relativeTo: Frame, inCoordinatesOf: Frame) -> None:
        ...
    @typing.overload
    def setTransform(self, newTransform: _nimblephysics.math.Isometry3) -> None:
        ...
    @typing.overload
    def setTransform(self, newTransform: _nimblephysics.math.Isometry3, withRespectTo: Frame) -> None:
        ...
class FreeJointProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, properties: FreeJointProperties) -> None:
        ...
class GenericJointProperties_R1(JointProperties, GenericJointUniqueProperties_R1):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R1) -> None:
        ...
class GenericJointProperties_R2(JointProperties, GenericJointUniqueProperties_R2):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R2) -> None:
        ...
class GenericJointProperties_R3(JointProperties, GenericJointUniqueProperties_R3):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R3) -> None:
        ...
class GenericJointProperties_R4(JointProperties, GenericJointUniqueProperties_R4):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R4) -> None:
        ...
class GenericJointProperties_R6(JointProperties, GenericJointUniqueProperties_R6):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_R6) -> None:
        ...
class GenericJointProperties_SE3(JointProperties, GenericJointUniqueProperties_SE3):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_SE3) -> None:
        ...
class GenericJointProperties_SO3(JointProperties, GenericJointUniqueProperties_SO3):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, jointProperties: JointProperties, genericProperties: GenericJointUniqueProperties_SO3) -> None:
        ...
class GenericJointUniqueProperties_R1:
    mAccelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]]
    mAccelerationUpperLimits: numpy.ndarray[numpy.float64[1, 1]]
    mDampingCoefficients: numpy.ndarray[numpy.float64[1, 1]]
    mDofNames: list[str[1]]
    mForceLowerLimits: numpy.ndarray[numpy.float64[1, 1]]
    mForceUpperLimits: numpy.ndarray[numpy.float64[1, 1]]
    mFrictions: numpy.ndarray[numpy.float64[1, 1]]
    mInitialPositions: numpy.ndarray[numpy.float64[1, 1]]
    mInitialVelocities: numpy.ndarray[numpy.float64[1, 1]]
    mPositionLowerLimits: numpy.ndarray[numpy.float64[1, 1]]
    mPositionUpperLimits: numpy.ndarray[numpy.float64[1, 1]]
    mPreserveDofNames: list[bool[1]]
    mRestPositions: numpy.ndarray[numpy.float64[1, 1]]
    mSpringStiffnesses: numpy.ndarray[numpy.float64[1, 1]]
    mVelocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]]
    mVelocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[1, 1]], springStiffness: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[1, 1]], springStiffness: numpy.ndarray[numpy.float64[1, 1]], restPosition: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[1, 1]], springStiffness: numpy.ndarray[numpy.float64[1, 1]], restPosition: numpy.ndarray[numpy.float64[1, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[1, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialPositions: numpy.ndarray[numpy.float64[1, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[1, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[1, 1]], initialVelocities: numpy.ndarray[numpy.float64[1, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[1, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[1, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[1, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[1, 1]], springStiffness: numpy.ndarray[numpy.float64[1, 1]], restPosition: numpy.ndarray[numpy.float64[1, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[1, 1]], coulombFrictions: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
class GenericJointUniqueProperties_R2:
    mAccelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]]
    mAccelerationUpperLimits: numpy.ndarray[numpy.float64[2, 1]]
    mDampingCoefficients: numpy.ndarray[numpy.float64[2, 1]]
    mDofNames: list[str[2]]
    mForceLowerLimits: numpy.ndarray[numpy.float64[2, 1]]
    mForceUpperLimits: numpy.ndarray[numpy.float64[2, 1]]
    mFrictions: numpy.ndarray[numpy.float64[2, 1]]
    mInitialPositions: numpy.ndarray[numpy.float64[2, 1]]
    mInitialVelocities: numpy.ndarray[numpy.float64[2, 1]]
    mPositionLowerLimits: numpy.ndarray[numpy.float64[2, 1]]
    mPositionUpperLimits: numpy.ndarray[numpy.float64[2, 1]]
    mPreserveDofNames: list[bool[2]]
    mRestPositions: numpy.ndarray[numpy.float64[2, 1]]
    mSpringStiffnesses: numpy.ndarray[numpy.float64[2, 1]]
    mVelocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]]
    mVelocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[2, 1]], springStiffness: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[2, 1]], springStiffness: numpy.ndarray[numpy.float64[2, 1]], restPosition: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[2, 1]], springStiffness: numpy.ndarray[numpy.float64[2, 1]], restPosition: numpy.ndarray[numpy.float64[2, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[2, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialPositions: numpy.ndarray[numpy.float64[2, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[2, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[2, 1]], initialVelocities: numpy.ndarray[numpy.float64[2, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[2, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[2, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[2, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[2, 1]], springStiffness: numpy.ndarray[numpy.float64[2, 1]], restPosition: numpy.ndarray[numpy.float64[2, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[2, 1]], coulombFrictions: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
class GenericJointUniqueProperties_R3:
    mAccelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]]
    mAccelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]]
    mDampingCoefficients: numpy.ndarray[numpy.float64[3, 1]]
    mDofNames: list[str[3]]
    mForceLowerLimits: numpy.ndarray[numpy.float64[3, 1]]
    mForceUpperLimits: numpy.ndarray[numpy.float64[3, 1]]
    mFrictions: numpy.ndarray[numpy.float64[3, 1]]
    mInitialPositions: numpy.ndarray[numpy.float64[3, 1]]
    mInitialVelocities: numpy.ndarray[numpy.float64[3, 1]]
    mPositionLowerLimits: numpy.ndarray[numpy.float64[3, 1]]
    mPositionUpperLimits: numpy.ndarray[numpy.float64[3, 1]]
    mPreserveDofNames: list[bool[3]]
    mRestPositions: numpy.ndarray[numpy.float64[3, 1]]
    mSpringStiffnesses: numpy.ndarray[numpy.float64[3, 1]]
    mVelocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]]
    mVelocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]], springStiffness: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]], springStiffness: numpy.ndarray[numpy.float64[3, 1]], restPosition: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]], springStiffness: numpy.ndarray[numpy.float64[3, 1]], restPosition: numpy.ndarray[numpy.float64[3, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]], springStiffness: numpy.ndarray[numpy.float64[3, 1]], restPosition: numpy.ndarray[numpy.float64[3, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[3, 1]], coulombFrictions: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class GenericJointUniqueProperties_R4:
    mAccelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]]
    mAccelerationUpperLimits: numpy.ndarray[numpy.float64[4, 1]]
    mDampingCoefficients: numpy.ndarray[numpy.float64[4, 1]]
    mDofNames: list[str[4]]
    mForceLowerLimits: numpy.ndarray[numpy.float64[4, 1]]
    mForceUpperLimits: numpy.ndarray[numpy.float64[4, 1]]
    mFrictions: numpy.ndarray[numpy.float64[4, 1]]
    mInitialPositions: numpy.ndarray[numpy.float64[4, 1]]
    mInitialVelocities: numpy.ndarray[numpy.float64[4, 1]]
    mPositionLowerLimits: numpy.ndarray[numpy.float64[4, 1]]
    mPositionUpperLimits: numpy.ndarray[numpy.float64[4, 1]]
    mPreserveDofNames: list[bool[4]]
    mRestPositions: numpy.ndarray[numpy.float64[4, 1]]
    mSpringStiffnesses: numpy.ndarray[numpy.float64[4, 1]]
    mVelocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]]
    mVelocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[4, 1]], springStiffness: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[4, 1]], springStiffness: numpy.ndarray[numpy.float64[4, 1]], restPosition: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[4, 1]], springStiffness: numpy.ndarray[numpy.float64[4, 1]], restPosition: numpy.ndarray[numpy.float64[4, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[4, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialPositions: numpy.ndarray[numpy.float64[4, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[4, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[4, 1]], initialVelocities: numpy.ndarray[numpy.float64[4, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[4, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[4, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[4, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[4, 1]], springStiffness: numpy.ndarray[numpy.float64[4, 1]], restPosition: numpy.ndarray[numpy.float64[4, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[4, 1]], coulombFrictions: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
class GenericJointUniqueProperties_R6:
    mAccelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]]
    mAccelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]]
    mDampingCoefficients: numpy.ndarray[numpy.float64[6, 1]]
    mDofNames: list[str[6]]
    mForceLowerLimits: numpy.ndarray[numpy.float64[6, 1]]
    mForceUpperLimits: numpy.ndarray[numpy.float64[6, 1]]
    mFrictions: numpy.ndarray[numpy.float64[6, 1]]
    mInitialPositions: numpy.ndarray[numpy.float64[6, 1]]
    mInitialVelocities: numpy.ndarray[numpy.float64[6, 1]]
    mPositionLowerLimits: numpy.ndarray[numpy.float64[6, 1]]
    mPositionUpperLimits: numpy.ndarray[numpy.float64[6, 1]]
    mPreserveDofNames: list[bool[6]]
    mRestPositions: numpy.ndarray[numpy.float64[6, 1]]
    mSpringStiffnesses: numpy.ndarray[numpy.float64[6, 1]]
    mVelocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]]
    mVelocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]], springStiffness: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]], springStiffness: numpy.ndarray[numpy.float64[6, 1]], restPosition: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]], springStiffness: numpy.ndarray[numpy.float64[6, 1]], restPosition: numpy.ndarray[numpy.float64[6, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]], springStiffness: numpy.ndarray[numpy.float64[6, 1]], restPosition: numpy.ndarray[numpy.float64[6, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[6, 1]], coulombFrictions: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
class GenericJointUniqueProperties_SE3:
    mAccelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]]
    mAccelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]]
    mDampingCoefficients: numpy.ndarray[numpy.float64[6, 1]]
    mDofNames: list[str[6]]
    mForceLowerLimits: numpy.ndarray[numpy.float64[6, 1]]
    mForceUpperLimits: numpy.ndarray[numpy.float64[6, 1]]
    mFrictions: numpy.ndarray[numpy.float64[6, 1]]
    mInitialPositions: numpy.ndarray[numpy.float64[6, 1]]
    mInitialVelocities: numpy.ndarray[numpy.float64[6, 1]]
    mPositionLowerLimits: numpy.ndarray[numpy.float64[6, 1]]
    mPositionUpperLimits: numpy.ndarray[numpy.float64[6, 1]]
    mPreserveDofNames: list[bool[6]]
    mRestPositions: numpy.ndarray[numpy.float64[6, 1]]
    mSpringStiffnesses: numpy.ndarray[numpy.float64[6, 1]]
    mVelocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]]
    mVelocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]], springStiffness: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]], springStiffness: numpy.ndarray[numpy.float64[6, 1]], restPosition: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]], springStiffness: numpy.ndarray[numpy.float64[6, 1]], restPosition: numpy.ndarray[numpy.float64[6, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[6, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialPositions: numpy.ndarray[numpy.float64[6, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[6, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[6, 1]], initialVelocities: numpy.ndarray[numpy.float64[6, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[6, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[6, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[6, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[6, 1]], springStiffness: numpy.ndarray[numpy.float64[6, 1]], restPosition: numpy.ndarray[numpy.float64[6, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[6, 1]], coulombFrictions: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
class GenericJointUniqueProperties_SO3:
    mAccelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]]
    mAccelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]]
    mDampingCoefficients: numpy.ndarray[numpy.float64[3, 1]]
    mDofNames: list[str[3]]
    mForceLowerLimits: numpy.ndarray[numpy.float64[3, 1]]
    mForceUpperLimits: numpy.ndarray[numpy.float64[3, 1]]
    mFrictions: numpy.ndarray[numpy.float64[3, 1]]
    mInitialPositions: numpy.ndarray[numpy.float64[3, 1]]
    mInitialVelocities: numpy.ndarray[numpy.float64[3, 1]]
    mPositionLowerLimits: numpy.ndarray[numpy.float64[3, 1]]
    mPositionUpperLimits: numpy.ndarray[numpy.float64[3, 1]]
    mPreserveDofNames: list[bool[3]]
    mRestPositions: numpy.ndarray[numpy.float64[3, 1]]
    mSpringStiffnesses: numpy.ndarray[numpy.float64[3, 1]]
    mVelocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]]
    mVelocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]], springStiffness: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]], springStiffness: numpy.ndarray[numpy.float64[3, 1]], restPosition: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]], springStiffness: numpy.ndarray[numpy.float64[3, 1]], restPosition: numpy.ndarray[numpy.float64[3, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, positionLowerLimits: numpy.ndarray[numpy.float64[3, 1]], positionUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialPositions: numpy.ndarray[numpy.float64[3, 1]], velocityLowerLimits: numpy.ndarray[numpy.float64[3, 1]], velocityUpperLimits: numpy.ndarray[numpy.float64[3, 1]], initialVelocities: numpy.ndarray[numpy.float64[3, 1]], accelerationLowerLimits: numpy.ndarray[numpy.float64[3, 1]], accelerationUpperLimits: numpy.ndarray[numpy.float64[3, 1]], forceLowerLimits: numpy.ndarray[numpy.float64[3, 1]], forceUpperLimits: numpy.ndarray[numpy.float64[3, 1]], springStiffness: numpy.ndarray[numpy.float64[3, 1]], restPosition: numpy.ndarray[numpy.float64[3, 1]], dampingCoefficient: numpy.ndarray[numpy.float64[3, 1]], coulombFrictions: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class GenericJoint_R1(EmbedStateAndPropertiesOnTopOf_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 1
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R1) -> None:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R1) -> None:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_R1:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[1, 1]], q1: numpy.ndarray[numpy.float64[1, 1]]) -> numpy.ndarray[numpy.float64[1, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[1, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R1) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R1) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64[1, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class GenericJoint_R2(EmbedStateAndPropertiesOnTopOf_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 2
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R2) -> None:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R2) -> None:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_R2:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[2, 1]], q1: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[6, 2]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R2) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R2) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class GenericJoint_R3(EmbedStateAndPropertiesOnTopOf_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 3
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R3) -> None:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R3) -> None:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_R3:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[3, 1]], q1: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, 3]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R3) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R3) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class GenericJoint_R4(EmbedStateAndPropertiesOnTopOf_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 4
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R4) -> None:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R4) -> None:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_R4:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[4, 1]], q1: numpy.ndarray[numpy.float64[4, 1]]) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[4, 1]]) -> numpy.ndarray[numpy.float64[6, 4]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R4) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R4) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class GenericJoint_R6(EmbedStateAndPropertiesOnTopOf_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 6
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R6) -> None:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_R6) -> None:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_R6:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[6, 1]], q1: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_R6) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_R6) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class GenericJoint_SE3(EmbedStateAndPropertiesOnTopOf_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 6
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_SE3) -> None:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_SE3) -> None:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_SE3:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[6, 1]], q1: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[6, 1]]) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_SE3) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_SE3) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class GenericJoint_SO3(EmbedStateAndPropertiesOnTopOf_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties_Joint):
    NumDofs: typing.ClassVar[int] = 3
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_SO3) -> None:
        ...
    @typing.overload
    def copy(self, otherJoint: GenericJoint_SO3) -> None:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getGenericJointProperties(self) -> GenericJointProperties_SO3:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionDifferencesStatic(self, q2: numpy.ndarray[numpy.float64[3, 1]], q1: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, 3]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationsStatic(self, accels: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> str:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> str:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionsStatic(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointProperties_SO3) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: GenericJointUniqueProperties_SO3) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocitiesStatic(self, velocities: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class Inertia:
    @typing.overload
    def __init__(self, inertiaMatrix: numpy.ndarray[numpy.float64[6, 6]]) -> None:
        ...
    @typing.overload
    def __init__(self, mass: float, centerOfMass: numpy.ndarray[numpy.float64[3, 1]], momentOfInertia: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
class JacobianNode(Frame):
    def dependsOn(self, genCoordIndex: int) -> bool:
        ...
    def dirtyJacobian(self) -> None:
        ...
    def dirtyJacobianDeriv(self) -> None:
        ...
    @typing.overload
    def getAngularJacobian(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    def getDependentGenCoordIndex(self, arrayIndex: int) -> int:
        ...
    @typing.overload
    def getJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    def getNumDependentDofs(self) -> int:
        ...
    def getNumDependentGenCoords(self) -> int:
        ...
    def getWorldJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
class Joint:
    class ActuatorType:
        """
        Members:
        
          FORCE
        
          PASSIVE
        
          SERVO
        
          MIMIC
        
          ACCELERATION
        
          VELOCITY
        
          LOCKED
        """
        ACCELERATION: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.ACCELERATION: 4>
        FORCE: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.FORCE: 0>
        LOCKED: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.LOCKED: 6>
        MIMIC: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.MIMIC: 3>
        PASSIVE: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.PASSIVE: 1>
        SERVO: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.SERVO: 2>
        VELOCITY: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.VELOCITY: 5>
        __members__: typing.ClassVar[dict[str, Joint.ActuatorType]]  # value = {'FORCE': <ActuatorType.FORCE: 0>, 'PASSIVE': <ActuatorType.PASSIVE: 1>, 'SERVO': <ActuatorType.SERVO: 2>, 'MIMIC': <ActuatorType.MIMIC: 3>, 'ACCELERATION': <ActuatorType.ACCELERATION: 4>, 'VELOCITY': <ActuatorType.VELOCITY: 5>, 'LOCKED': <ActuatorType.LOCKED: 6>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    ACCELERATION: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.ACCELERATION: 4>
    DefaultActuatorType: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.FORCE: 0>
    FORCE: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.FORCE: 0>
    LOCKED: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.LOCKED: 6>
    PASSIVE: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.PASSIVE: 1>
    SERVO: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.SERVO: 2>
    VELOCITY: typing.ClassVar[Joint.ActuatorType]  # value = <ActuatorType.VELOCITY: 5>
    @typing.overload
    def checkSanity(self) -> bool:
        ...
    @typing.overload
    def checkSanity(self, printWarnings: bool) -> bool:
        ...
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def copy(self, otherJoint: Joint) -> None:
        ...
    @typing.overload
    def copy(self, otherJoint: Joint) -> None:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getActuatorType(self) -> Joint.ActuatorType:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getChildBodyNode(self) -> BodyNode:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, index: int) -> str:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getJointIndexInSkeleton(self) -> int:
        ...
    def getJointIndexInTree(self) -> int:
        ...
    def getName(self) -> str:
        ...
    def getNearestPositionToDesiredRotation(self, arg0: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getNumDofs(self) -> int:
        ...
    def getParentBodyNode(self) -> BodyNode:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRelativeJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getRelativeJacobian(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativeJacobianTimeDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def getRelativePrimaryAcceleration(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getRelativeSpatialAcceleration(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getRelativeSpatialVelocity(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getRelativeTransform(self) -> _nimblephysics.math.Isometry3:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getTransformFromChildBodyNode(self) -> _nimblephysics.math.Isometry3:
        ...
    def getTransformFromParentBodyNode(self) -> _nimblephysics.math.Isometry3:
        ...
    def getTreeIndex(self) -> int:
        ...
    def getType(self) -> str:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def isDofNamePreserved(self, index: int) -> bool:
        ...
    def isDynamic(self) -> bool:
        ...
    def isKinematic(self) -> bool:
        ...
    def isPositionLimitEnforced(self) -> bool:
        ...
    def notifyAccelerationUpdated(self) -> None:
        ...
    def notifyPositionUpdated(self) -> None:
        ...
    def notifyVelocityUpdated(self) -> None:
        ...
    def preserveDofName(self, index: int, preserve: bool) -> None:
        ...
    def removeJointAspect(self) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setActuatorType(self, actuatorType: Joint.ActuatorType) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, coeff: float) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str) -> None:
        ...
    @typing.overload
    def setDofName(self, index: int, name: str, preserveName: bool) -> None:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    @typing.overload
    def setName(self, name: str) -> None:
        ...
    @typing.overload
    def setName(self, name: str, renameDofs: bool) -> None:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLimitEnforced(self, isPositionLimitEnforced: bool) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setProperties(self, properties: JointProperties) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setTransformFromChildBodyNode(self, T: _nimblephysics.math.Isometry3) -> None:
        ...
    def setTransformFromParentBodyNode(self, T: _nimblephysics.math.Isometry3) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class JointEnergyTransmitter:
    childBody: str
    childCenter: numpy.ndarray[numpy.float64[3, 1]]
    name: str
    parentBody: str
    parentCenter: numpy.ndarray[numpy.float64[3, 1]]
    powerToChild: float
    powerToParent: float
    worldCenter: numpy.ndarray[numpy.float64[3, 1]]
    def __init__(self) -> None:
        ...
class JointProperties:
    mActuatorType: Joint.ActuatorType
    mIsPositionLimitEnforced: bool
    mMimicJoint: Joint
    mMimicMultiplier: float
    mMimicOffset: float
    mName: str
    mT_ChildBodyToJoint: _nimblephysics.math.Isometry3
    mT_ParentBodyToJoint: _nimblephysics.math.Isometry3
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, name: str) -> None:
        ...
class LineSegmentShape(Shape):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, thickness: float) -> None:
        ...
    @typing.overload
    def __init__(self, v1: numpy.ndarray[numpy.float64[3, 1]], v2: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, v1: numpy.ndarray[numpy.float64[3, 1]], v2: numpy.ndarray[numpy.float64[3, 1]], thickness: float) -> None:
        ...
    def addConnection(self, idx1: int, idx2: int) -> None:
        ...
    @typing.overload
    def addVertex(self, v: numpy.ndarray[numpy.float64[3, 1]]) -> int:
        ...
    @typing.overload
    def addVertex(self, v: numpy.ndarray[numpy.float64[3, 1]], parent: int) -> int:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getThickness(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def getVertex(self, idx: int) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def removeConnection(self, vertexIdx1: int, vertexIdx2: int) -> None:
        ...
    @typing.overload
    def removeConnection(self, connectionIdx: int) -> None:
        ...
    def removeVertex(self, idx: int) -> None:
        ...
    def setThickness(self, thickness: float) -> None:
        ...
    def setVertex(self, idx: int, v: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class MeshShape(Shape):
    class ColorMode:
        """
        Members:
        
          MATERIAL_COLOR
        
          COLOR_INDEX
        
          SHAPE_COLOR
        """
        COLOR_INDEX: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.COLOR_INDEX: 1>
        MATERIAL_COLOR: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.MATERIAL_COLOR: 0>
        SHAPE_COLOR: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.SHAPE_COLOR: 2>
        __members__: typing.ClassVar[dict[str, MeshShape.ColorMode]]  # value = {'MATERIAL_COLOR': <ColorMode.MATERIAL_COLOR: 0>, 'COLOR_INDEX': <ColorMode.COLOR_INDEX: 1>, 'SHAPE_COLOR': <ColorMode.SHAPE_COLOR: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    COLOR_INDEX: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.COLOR_INDEX: 1>
    MATERIAL_COLOR: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.MATERIAL_COLOR: 0>
    SHAPE_COLOR: typing.ClassVar[MeshShape.ColorMode]  # value = <ColorMode.SHAPE_COLOR: 2>
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64[3, 1]], mesh: SharedMeshWrapper) -> None:
        ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64[3, 1]], mesh: SharedMeshWrapper, uri: _nimblephysics.common.Uri) -> None:
        ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64[3, 1]], mesh: SharedMeshWrapper, uri: _nimblephysics.common.Uri, resourceRetriever: _nimblephysics.common.ResourceRetriever) -> None:
        ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64[3, 1]], path: str) -> None:
        ...
    @typing.overload
    def __init__(self, scale: numpy.ndarray[numpy.float64[3, 1]], path: str, resourceRetriever: _nimblephysics.common.ResourceRetriever) -> None:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getDisplayList(self) -> int:
        ...
    def getMeshPath(self) -> str:
        ...
    def getMeshUri(self) -> str:
        ...
    def getMeshUri2(self) -> _nimblephysics.common.Uri:
        ...
    def getResourceRetriever(self) -> _nimblephysics.common.ResourceRetriever:
        ...
    def getScale(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getType(self) -> str:
        ...
    def notifyAlphaUpdated(self, alpha: float) -> None:
        ...
    def setDisplayList(self, index: int) -> None:
        ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper) -> None:
        ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper, path: str) -> None:
        ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper, path: str, resourceRetriever: _nimblephysics.common.ResourceRetriever) -> None:
        ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper, path: _nimblephysics.common.Uri) -> None:
        ...
    @typing.overload
    def setMesh(self, mesh: SharedMeshWrapper, path: _nimblephysics.common.Uri, resourceRetriever: _nimblephysics.common.ResourceRetriever) -> None:
        ...
    def setScale(self, scale: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def update(self) -> None:
        ...
class MetaSkeleton:
    def clearExternalForces(self) -> None:
        ...
    def clearInternalForces(self) -> None:
        ...
    @typing.overload
    def cloneMetaSkeleton(self, cloneName: str) -> MetaSkeleton:
        ...
    @typing.overload
    def cloneMetaSkeleton(self) -> MetaSkeleton:
        ...
    def computeKineticEnergy(self) -> float:
        ...
    def computeLagrangian(self) -> float:
        ...
    def computePotentialEnergy(self) -> float:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getAccelerationLowerLimits(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getAccelerationUpperLimits(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getAccelerations(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, relativeTo: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    def getAugMassMatrix(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def getBodyNode(self, index: int) -> BodyNode:
        ...
    @typing.overload
    def getBodyNode(self, treeIndex: str) -> BodyNode:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> list[BodyNode]:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> list[BodyNode]:
        ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    @typing.overload
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getCommands(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getControlForceLowerLimits(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getControlForceUpperLimits(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getControlForces(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoriolisAndGravityForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoriolisForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getDof(self, index: int) -> DegreeOfFreedom:
        ...
    def getDofs(self) -> list[DegreeOfFreedom]:
        ...
    def getExternalForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGravityForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int:
        ...
    def getInvMassMatrix(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJoint(self, index: int) -> Joint:
        ...
    @typing.overload
    def getJoint(self, name: str) -> Joint:
        ...
    def getJointConstraintImpulses(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getJoints(self) -> list[Joint]:
        ...
    @typing.overload
    def getJoints(self) -> list[Joint]:
        ...
    @typing.overload
    def getJoints(self, name: str) -> list[Joint]:
        ...
    @typing.overload
    def getJoints(self, name: str) -> list[Joint]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, relativeTo: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], relativeTo: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    def getMass(self) -> float:
        ...
    def getMassMatrix(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getName(self) -> str:
        ...
    def getNumBodyNodes(self) -> int:
        ...
    def getNumDofs(self) -> int:
        ...
    def getNumJoints(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getPositionLowerLimits(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getPositionUpperLimits(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getPositions(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getVelocities(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChanges(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getVelocityLowerLimits(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    @typing.overload
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getVelocityUpperLimits(self, indices: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool:
        ...
    def hasJoint(self, joint: Joint) -> bool:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetGeneralizedForces(self) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    @typing.overload
    def setAccelerationLowerLimits(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setAccelerationLowerLimits(self, indices: list[int], accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    @typing.overload
    def setAccelerationUpperLimits(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setAccelerationUpperLimits(self, indices: list[int], accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setAccelerations(self, indices: list[int], accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    @typing.overload
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setCommands(self, indices: list[int], commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    @typing.overload
    def setControlForceLowerLimits(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setControlForceLowerLimits(self, indices: list[int], forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    @typing.overload
    def setControlForceUpperLimits(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setControlForceUpperLimits(self, indices: list[int], forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setControlForces(self, index: list[int], forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setJointConstraintImpulses(self, impulses: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setName(self, name: str) -> str:
        ...
    def setPosition(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    @typing.overload
    def setPositionLowerLimits(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setPositionLowerLimits(self, indices: list[int], positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    @typing.overload
    def setPositionUpperLimits(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setPositionUpperLimits(self, indices: list[int], positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setPositions(self, indices: list[int], positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setVelocities(self, indices: list[int], velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    @typing.overload
    def setVelocityLowerLimits(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setVelocityLowerLimits(self, indices: list[int], velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    @typing.overload
    def setVelocityUpperLimits(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setVelocityUpperLimits(self, indices: list[int], velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class MultiSphereConvexHullShape(Shape):
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, spheres: list[tuple[float, numpy.ndarray[numpy.float64[3, 1]]]]) -> None:
        ...
    @typing.overload
    def addSphere(self, sphere: tuple[float, numpy.ndarray[numpy.float64[3, 1]]]) -> None:
        ...
    @typing.overload
    def addSphere(self, radius: float, position: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def addSpheres(self, spheres: list[tuple[float, numpy.ndarray[numpy.float64[3, 1]]]]) -> None:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getNumSpheres(self) -> int:
        ...
    def getType(self) -> str:
        ...
    def removeAllSpheres(self) -> None:
        ...
class MultipleContactInverseDynamicsOverTimeResult:
    accelerations: numpy.ndarray[numpy.float64[m, n]]
    contactBodies: list[BodyNode]
    contactWrenches: list[list[numpy.ndarray[numpy.float64[6, 1]]]]
    jointTorques: numpy.ndarray[numpy.float64[m, n]]
    positions: numpy.ndarray[numpy.float64[m, n]]
    prevContactForces: list[numpy.ndarray[numpy.float64[6, 1]]]
    skel: Skeleton
    timesteps: int
    velocities: numpy.ndarray[numpy.float64[m, n]]
    def __init__(self) -> None:
        ...
    def computePrevForceLoss(self) -> float:
        ...
    def computeSmoothnessLoss(self) -> float:
        ...
    def sumError(self) -> float:
        ...
class MultipleContactInverseDynamicsResult:
    acc: numpy.ndarray[numpy.float64[m, 1]]
    contactBodies: list[BodyNode]
    contactWrenchGuesses: list[numpy.ndarray[numpy.float64[6, 1]]]
    contactWrenches: list[numpy.ndarray[numpy.float64[6, 1]]]
    jointTorques: numpy.ndarray[numpy.float64[m, 1]]
    pos: numpy.ndarray[numpy.float64[m, 1]]
    skel: Skeleton
    vel: numpy.ndarray[numpy.float64[m, 1]]
    def __init__(self) -> None:
        ...
    def computeGuessLoss(self) -> float:
        ...
    def sumError(self) -> float:
        ...
class Node:
    def getName(self) -> str:
        ...
    def getNodeProperties(self) -> NodeProperties:
        ...
    def getNodeState(self) -> NodeState:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    def isRemoved(self) -> bool:
        ...
    def setName(self, newName: str) -> str:
        ...
    def setNodeProperties(self, properties: NodeProperties) -> None:
        ...
    def setNodeState(self, otherState: NodeState) -> None:
        ...
class NodeProperties:
    pass
class NodeState:
    pass
class PlanarJoint(EmbedPropertiesOnTopOf_PlanarJoint_PlanarJointUniqueProperties_GenericJoint_R3Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: PlanarJoint) -> None:
        ...
    def getPlanarJointProperties(self) -> PlanarJointProperties:
        ...
    def getPlaneType(self) -> PlaneType:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, 3]]:
        ...
    def getRotationalAxis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getTranslationalAxis1(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getTranslationalAxis2(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[numpy.float64[3, 1]], transAxis2: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[numpy.float64[3, 1]], transAxis2: numpy.ndarray[numpy.float64[3, 1]], renameDofs: bool) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: PlanarJointProperties) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: PlanarJointUniqueProperties) -> None:
        ...
    @typing.overload
    def setXYPlane(self) -> None:
        ...
    @typing.overload
    def setXYPlane(self, renameDofs: bool) -> None:
        ...
    @typing.overload
    def setYZPlane(self) -> None:
        ...
    @typing.overload
    def setYZPlane(self, renameDofs: bool) -> None:
        ...
    @typing.overload
    def setZXPlane(self) -> None:
        ...
    @typing.overload
    def setZXPlane(self, renameDofs: bool) -> None:
        ...
class PlanarJointProperties(PlanarJointUniqueProperties):
    mPlaneType: PlaneType
    mRotAxis: numpy.ndarray[numpy.float64[3, 1]]
    mTransAxis1: numpy.ndarray[numpy.float64[3, 1]]
    mTransAxis2: numpy.ndarray[numpy.float64[3, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: PlanarJointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: PlanarJointProperties, uniqueProperties: PlanarJointUniqueProperties) -> None:
        ...
class PlanarJointUniqueProperties:
    def __init__(self) -> None:
        ...
class PlaneShape(Shape):
    @staticmethod
    def getStaticType() -> str:
        ...
    @typing.overload
    def __init__(self, normal: numpy.ndarray[numpy.float64[3, 1]], offset: float) -> None:
        ...
    @typing.overload
    def __init__(self, normal: numpy.ndarray[numpy.float64[3, 1]], point: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def computeDistance(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def computeSignedDistance(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    def getNormal(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getOffset(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setNormal(self, normal: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setNormalAndOffset(self, normal: numpy.ndarray[numpy.float64[3, 1]], offset: float) -> None:
        ...
    def setNormalAndPoint(self, normal: numpy.ndarray[numpy.float64[3, 1]], point: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setOffset(self, offset: float) -> None:
        ...
class PlaneType:
    """
    Members:
    
      XY
    
      YZ
    
      ZX
    
      ARBITRARY
    """
    ARBITRARY: typing.ClassVar[PlaneType]  # value = <PlaneType.ARBITRARY: 3>
    XY: typing.ClassVar[PlaneType]  # value = <PlaneType.XY: 0>
    YZ: typing.ClassVar[PlaneType]  # value = <PlaneType.YZ: 1>
    ZX: typing.ClassVar[PlaneType]  # value = <PlaneType.ZX: 2>
    __members__: typing.ClassVar[dict[str, PlaneType]]  # value = {'XY': <PlaneType.XY: 0>, 'YZ': <PlaneType.YZ: 1>, 'ZX': <PlaneType.ZX: 2>, 'ARBITRARY': <PlaneType.ARBITRARY: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class PrismaticJoint(EmbedPropertiesOnTopOf_PrismaticJoint_PrismaticJointUniqueProperties_GenericJoint_R1Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: PrismaticJoint) -> None:
        ...
    def getAxis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getPrismaticJointProperties(self) -> PrismaticJointProperties:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[1, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setAxis(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: PrismaticJointProperties) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: PrismaticJointUniqueProperties) -> None:
        ...
class PrismaticJointProperties(PrismaticJointUniqueProperties):
    mAxis: numpy.ndarray[numpy.float64[3, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: PrismaticJointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: PrismaticJointProperties, revoluteProperties: PrismaticJointUniqueProperties) -> None:
        ...
class PrismaticJointUniqueProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class ReferentialSkeleton(MetaSkeleton):
    def clearExternalForces(self) -> None:
        ...
    def clearInternalForces(self) -> None:
        ...
    def computeKineticEnergy(self) -> float:
        ...
    def computePotentialEnergy(self) -> float:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> list[BodyNode]:
        ...
    @typing.overload
    def getBodyNodes(self, name: str) -> list[BodyNode]:
        ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getDofs(self) -> list[DegreeOfFreedom]:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJoints(self) -> list[Joint]:
        ...
    @typing.overload
    def getJoints(self) -> list[Joint]:
        ...
    @typing.overload
    def getJoints(self, name: str) -> list[Joint]:
        ...
    @typing.overload
    def getJoints(self, name: str) -> list[Joint]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    def getMass(self) -> float:
        ...
    def getName(self) -> str:
        ...
    def getNumBodyNodes(self) -> int:
        ...
    def getNumDofs(self) -> int:
        ...
    def getNumJoints(self) -> int:
        ...
    def getNumSkeletons(self) -> int:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool:
        ...
    def hasJoint(self, joint: Joint) -> bool:
        ...
    def hasSkeleton(self, skel: Skeleton) -> bool:
        ...
    def setName(self, name: str) -> str:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties(SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RequiresAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties(SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties):
    def __init__(self) -> None:
        ...
class RevoluteJoint(EmbedPropertiesOnTopOf_RevoluteJoint_RevoluteJointUniqueProperties_GenericJoint_R1Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: RevoluteJoint) -> None:
        ...
    def getAxis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[1, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getRevoluteJointProperties(self) -> RevoluteJointProperties:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setAxis(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: RevoluteJointProperties) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: RevoluteJointUniqueProperties) -> None:
        ...
class RevoluteJointProperties(RevoluteJointUniqueProperties):
    mAxis: numpy.ndarray[numpy.float64[3, 1]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: RevoluteJointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: RevoluteJointProperties, uniqueProperties: RevoluteJointUniqueProperties) -> None:
        ...
class RevoluteJointUniqueProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class ScapulothoracicJoint(GenericJoint_R4):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getAxisOrder(self) -> AxisOrder:
        ...
    def getEllipsoidRadii(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getFlipAxisMap(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[4, 1]]) -> numpy.ndarray[numpy.float64[6, 4]]:
        ...
    def getType(self) -> str:
        ...
    def getWingingAxisDirection(self) -> float:
        ...
    def getWingingAxisOffset(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setAxisOrder(self, order: AxisOrder, renameDofs: bool) -> None:
        ...
    def setEllipsoidRadii(self, radii: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setFlipAxisMap(self, flipMap: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    def setWingingAxisDirection(self, direction: float) -> None:
        ...
    def setWingingAxisOffset(self, offset: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
class ScrewJoint(EmbedPropertiesOnTopOf_ScrewJoint_ScrewJointUniqueProperties_GenericJoint_R1Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: ScrewJoint) -> None:
        ...
    def getAxis(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getPitch(self) -> float:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[1, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getScrewJointProperties(self) -> ScrewJointProperties:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setAxis(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setPitch(self, pitch: float) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: ScrewJointProperties) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: ScrewJointUniqueProperties) -> None:
        ...
class ScrewJointProperties(ScrewJointUniqueProperties):
    mAxis: numpy.ndarray[numpy.float64[3, 1]]
    mPitch: float
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: ScrewJointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: ScrewJointProperties, revoluteProperties: ScrewJointUniqueProperties) -> None:
        ...
class ScrewJointUniqueProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, axis: numpy.ndarray[numpy.float64[3, 1]], pitch: float) -> None:
        ...
class Shape:
    def addDataVariance(self, variance: int) -> None:
        ...
    def checkDataVariance(self, type: DataVariance) -> bool:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def computeInertiaFromDensity(self, density: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def computeInertiaFromMass(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getBoundingBox(self) -> _nimblephysics.math.BoundingBox:
        ...
    def getDataVariance(self) -> int:
        ...
    def getID(self) -> int:
        ...
    def getType(self) -> str:
        ...
    def getVolume(self) -> float:
        ...
    def incrementVersion(self) -> int:
        ...
    def notifyAlphaUpdated(self, alpha: float) -> None:
        ...
    def notifyColorUpdated(self, color: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    def refreshData(self) -> None:
        ...
    def removeDataVariance(self, variance: int) -> None:
        ...
    def setDataVariance(self, variance: int) -> None:
        ...
class ShapeFrame(Frame):
    def createCollisionAspect(self) -> CollisionAspect:
        ...
    def createDynamicsAspect(self) -> DynamicsAspect:
        ...
    def createVisualAspect(self) -> VisualAspect:
        ...
    @typing.overload
    def getCollisionAspect(self) -> CollisionAspect:
        ...
    @typing.overload
    def getCollisionAspect(self, createIfNull: bool) -> CollisionAspect:
        ...
    @typing.overload
    def getDynamicsAspect(self) -> DynamicsAspect:
        ...
    @typing.overload
    def getDynamicsAspect(self, createIfNull: bool) -> DynamicsAspect:
        ...
    @typing.overload
    def getShape(self) -> Shape:
        ...
    @typing.overload
    def getShape(self) -> Shape:
        ...
    @typing.overload
    def getVisualAspect(self) -> VisualAspect:
        ...
    @typing.overload
    def getVisualAspect(self, createIfNull: bool) -> VisualAspect:
        ...
    def hasCollisionAspect(self) -> bool:
        ...
    def hasDynamicsAspect(self) -> bool:
        ...
    def hasVisualAspect(self) -> bool:
        ...
    def isShapeNode(self) -> bool:
        ...
    def releaseCollisionAspect(self) -> CollisionAspect:
        ...
    def releaseDynamicsAspect(self) -> DynamicsAspect:
        ...
    def releaseVisualAspect(self) -> VisualAspect:
        ...
    def removeCollisionAspect(self) -> None:
        ...
    def removeDynamicsAspect(self) -> None:
        ...
    def removeVisualAspect(self) -> None:
        ...
    def setCollisionAspect(self, aspect: CollisionAspect) -> None:
        ...
    def setDynamicsAspect(self, aspect: DynamicsAspect) -> None:
        ...
    def setProperties(self, properties: ShapeFrameProperties) -> None:
        ...
    def setShape(self, shape: Shape) -> None:
        ...
    def setVisualAspect(self, aspect: VisualAspect) -> None:
        ...
class ShapeFrameProperties:
    pass
class ShapeNode(ShapeFrame):
    def copy(self, other: ShapeNode) -> None:
        ...
    def createCollisionAspect(self) -> CollisionAspect:
        ...
    def createDynamicsAspect(self) -> DynamicsAspect:
        ...
    def createVisualAspect(self) -> VisualAspect:
        ...
    def getName(self) -> str:
        ...
    def getOffset(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRelativeRotation(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getRelativeTranslation(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getShapeNodeProperties(self) -> ShapeNodeProperties:
        ...
    def setOffset(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setProperties(self, properties: ShapeNodeProperties) -> None:
        ...
    def setRelativeRotation(self, rotation: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    def setRelativeTransform(self, transform: _nimblephysics.math.Isometry3) -> None:
        ...
    def setRelativeTranslation(self, translation: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
class ShapeNodeProperties:
    pass
class SharedMeshWrapper:
    pass
class SimpleFrame(ShapeFrame):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, refFrame: Frame) -> None:
        ...
    @typing.overload
    def __init__(self, refFrame: Frame, name: str) -> None:
        ...
    @typing.overload
    def __init__(self, refFrame: Frame, name: str, relativeTransform: _nimblephysics.math.Isometry3) -> None:
        ...
    @typing.overload
    def clone(self) -> SimpleFrame:
        ...
    @typing.overload
    def clone(self, refFrame: Frame) -> SimpleFrame:
        ...
    @typing.overload
    def copy(self, otherFrame: Frame) -> None:
        ...
    @typing.overload
    def copy(self, otherFrame: Frame, refFrame: Frame) -> None:
        ...
    @typing.overload
    def copy(self, otherFrame: Frame, refFrame: Frame, copyProperties: bool) -> None:
        ...
    def getName(self) -> str:
        ...
    @typing.overload
    def setClassicDerivatives(self) -> None:
        ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[numpy.float64[3, 1]], angularVelocity: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[numpy.float64[3, 1]], angularVelocity: numpy.ndarray[numpy.float64[3, 1]], linearAcceleration: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setClassicDerivatives(self, linearVelocity: numpy.ndarray[numpy.float64[3, 1]], angularVelocity: numpy.ndarray[numpy.float64[3, 1]], linearAcceleration: numpy.ndarray[numpy.float64[3, 1]], angularAcceleration: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setName(self, name: str) -> str:
        ...
    def setRelativeRotation(self, newRotation: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def setRelativeSpatialAcceleration(self, newSpatialAcceleration: numpy.ndarray[numpy.float64[6, 1]], inCoordinatesOf: Frame) -> None:
        ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def setRelativeSpatialVelocity(self, newSpatialVelocity: numpy.ndarray[numpy.float64[6, 1]], inCoordinatesOf: Frame) -> None:
        ...
    def setRelativeTransform(self, newRelTransform: _nimblephysics.math.Isometry3) -> None:
        ...
    def setRelativeTranslation(self, newTranslation: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setRotation(self, newRotation: numpy.ndarray[numpy.float64[3, 3]]) -> None:
        ...
    @typing.overload
    def setRotation(self, newRotation: numpy.ndarray[numpy.float64[3, 3]], withRespectTo: Frame) -> None:
        ...
    @typing.overload
    def setTransform(self, newTransform: _nimblephysics.math.Isometry3) -> None:
        ...
    @typing.overload
    def setTransform(self, newTransform: _nimblephysics.math.Isometry3, withRespectTo: Frame) -> None:
        ...
    @typing.overload
    def setTranslation(self, newTranslation: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setTranslation(self, newTranslation: numpy.ndarray[numpy.float64[3, 1]], withRespectTo: Frame) -> None:
        ...
    @typing.overload
    def spawnChildSimpleFrame(self) -> SimpleFrame:
        ...
    @typing.overload
    def spawnChildSimpleFrame(self, name: str) -> SimpleFrame:
        ...
    @typing.overload
    def spawnChildSimpleFrame(self, name: str, relativeTransform: _nimblephysics.math.Isometry3) -> SimpleFrame:
        ...
class Skeleton(MetaSkeleton):
    mUnionIndex: int
    mUnionSize: int
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, name: str) -> None:
        ...
    def autogroupSymmetricPrefixes(self, firstPrefix: str = ..., secondPrefix: str = ...) -> None:
        ...
    def autogroupSymmetricSuffixes(self, leftSuffix: str = ..., rightSuffix: str = ...) -> None:
        ...
    def checkIndexingConsistency(self) -> bool:
        ...
    def clampPositionsToLimits(self) -> None:
        ...
    def clearCollidingBodies(self) -> None:
        ...
    def clearConstraintImpulses(self) -> None:
        ...
    def clearExternalForces(self) -> None:
        ...
    def clearInternalForces(self) -> None:
        ...
    @typing.overload
    def clone(self) -> Skeleton:
        ...
    @typing.overload
    def clone(self, cloneName: str) -> Skeleton:
        ...
    def computeForwardDynamics(self) -> None:
        ...
    @typing.overload
    def computeForwardKinematics(self) -> None:
        ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool) -> None:
        ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool, updateVels: bool) -> None:
        ...
    @typing.overload
    def computeForwardKinematics(self, updateTransforms: bool, updateVels: bool, updateAccs: bool) -> None:
        ...
    def computeImpulseForwardDynamics(self) -> None:
        ...
    @typing.overload
    def computeInverseDynamics(self) -> None:
        ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool) -> None:
        ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool, withDampingForces: bool) -> None:
        ...
    @typing.overload
    def computeInverseDynamics(self, withExternalForces: bool, withDampingForces: bool, withSpringForces: bool) -> None:
        ...
    def computeKineticEnergy(self) -> float:
        ...
    def computePotentialEnergy(self) -> float:
        ...
    def convertMarkerMap(self, markerMap: dict[str, tuple[BodyNode, numpy.ndarray[numpy.float64[3, 1]]]], warnOnDrop: bool = ...) -> dict[str, tuple[BodyNode, numpy.ndarray[numpy.float64[3, 1]]]]:
        ...
    def convertSensorMap(self, sensorMap: dict[str, tuple[BodyNode, _nimblephysics.math.Isometry3]], warnOnDrop: bool = ...) -> dict[str, tuple[BodyNode, _nimblephysics.math.Isometry3]]:
        """
        This converts markers from a source skeleton to the current, doing a
        simple mapping based on body node names. Any markers that don't find a
        body node in the current skeleton with the same name are dropped.
        """
    @typing.overload
    def createBallJointAndBodyNodePair(self) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode, jointProperties: BallJointProperties) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createBallJointAndBodyNodePair(self, parent: BodyNode, jointProperties: BallJointProperties, bodyProperties: BodyNodeProperties) -> tuple[BallJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode, jointProperties: EulerJointProperties) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createEulerJointAndBodyNodePair(self, parent: BodyNode, jointProperties: EulerJointProperties, bodyProperties: BodyNodeProperties) -> tuple[EulerJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode, jointProperties: FreeJointProperties) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createFreeJointAndBodyNodePair(self, parent: BodyNode, jointProperties: FreeJointProperties, bodyProperties: BodyNodeProperties) -> tuple[FreeJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PlanarJointProperties) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPlanarJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PlanarJointProperties, bodyProperties: BodyNodeProperties) -> tuple[PlanarJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PrismaticJointProperties) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createPrismaticJointAndBodyNodePair(self, parent: BodyNode, jointProperties: PrismaticJointProperties, bodyProperties: BodyNodeProperties) -> tuple[PrismaticJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode, jointProperties: RevoluteJointProperties) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createRevoluteJointAndBodyNodePair(self, parent: BodyNode, jointProperties: RevoluteJointProperties, bodyProperties: BodyNodeProperties) -> tuple[RevoluteJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode, jointProperties: ScrewJointProperties) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createScrewJointAndBodyNodePair(self, parent: BodyNode, jointProperties: ScrewJointProperties, bodyProperties: BodyNodeProperties) -> tuple[ScrewJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJoint2DProperties) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJoint2DAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJoint2DProperties, bodyProperties: BodyNodeProperties) -> tuple[TranslationalJoint2D, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJointProperties) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createTranslationalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: TranslationalJointProperties, bodyProperties: BodyNodeProperties) -> tuple[TranslationalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: UniversalJointProperties) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createUniversalJointAndBodyNodePair(self, parent: BodyNode, jointProperties: UniversalJointProperties, bodyProperties: BodyNodeProperties) -> tuple[UniversalJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self) -> tuple[WeldJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode) -> tuple[WeldJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode, jointProperties: WeldJointProperties) -> tuple[WeldJoint, BodyNode]:
        ...
    @typing.overload
    def createWeldJointAndBodyNodePair(self, parent: BodyNode, jointProperties: WeldJointProperties, bodyProperties: BodyNodeProperties) -> tuple[WeldJoint, BodyNode]:
        ...
    def dirtyArticulatedInertia(self, treeIdx: int) -> None:
        ...
    def dirtySupportPolygon(self, treeIdx: int) -> None:
        ...
    def disableAdjacentBodyCheck(self) -> None:
        ...
    def disableSelfCollisionCheck(self) -> None:
        ...
    def enableAdjacentBodyCheck(self) -> None:
        ...
    def enableSelfCollisionCheck(self) -> None:
        ...
    def fitJointsToWorldPositions(self, positionJoints: list[Joint], targetPositions: numpy.ndarray[numpy.float64[m, 1]], scaleBodies: bool = ..., convergenceThreshold: float = ..., maxStepCount: int = ..., leastSquaresDamping: float = ..., lineSearch: bool = ..., logOutput: bool = ...) -> float:
        ...
    def fitMarkersToWorldPositions(self, markers: list[tuple[BodyNode, numpy.ndarray[numpy.float64[3, 1]]]], targetPositions: numpy.ndarray[numpy.float64[m, 1]], markerWeights: numpy.ndarray[numpy.float64[m, 1]], scaleBodies: bool = ..., convergenceThreshold: float = ..., maxStepCount: int = ..., leastSquaresDamping: float = ..., lineSearch: bool = ..., logOutput: bool = ...) -> float:
        ...
    def getAccMapReadings(self, accelerometers: dict[str, tuple[BodyNode, _nimblephysics.math.Isometry3]]) -> dict[str, numpy.ndarray[numpy.float64[3, 1]]]:
        """
        These are a set of bodies, and offsets in local body space where gyros
        are mounted on the body
        """
    def getAccelerometerReadings(self, accelerometers: list[tuple[BodyNode, _nimblephysics.math.Isometry3]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        """
        These are a set of bodies, and offsets in local body space where accs are mounted on the body.
        """
    def getAccelerometerReadingsJacobianWrt(self, accs: list[tuple[BodyNode, _nimblephysics.math.Isometry3]], wrt: _nimblephysics.neural.WithRespectTo) -> numpy.ndarray[numpy.float64[m, n]]:
        """
        This returns the Jacobian relating changes in the `wrt` quantity to changes in acc readings.
        """
    def getAdjacentBodyCheck(self) -> bool:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobian(self, node: JacobianNode, rotation: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAugMassMatrix(self, arg0: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def getAugMassMatrix(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getBodyForMesh(self, meshFileName: str) -> BodyNode:
        ...
    def getBodyNodes(self) -> list[BodyNode]:
        ...
    def getBodyScaleGroup(self, index: int) -> BodyScaleGroup:
        ...
    def getBodyScaleGroups(self) -> list[BodyScaleGroup]:
        ...
    def getBodyScales(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getCOM(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOM(self, withRespectTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMJacobian(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMLinearVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialAcceleration(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getCOMSpatialVelocity(self, relativeTo: Frame, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def getConstraintForces(self, arg0: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getConstraintForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getContactInverseDynamics(self, accelerations: numpy.ndarray[numpy.float64[m, 1]], contactBody: BodyNode) -> ContactInverseDynamicsResult:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getCoriolisAndGravityForces(self, arg0: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getCoriolisAndGravityForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getCoriolisForces(self, arg0: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getCoriolisForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getDof(self, name: str) -> DegreeOfFreedom:
        ...
    def getDofByIndex(self, index: int) -> DegreeOfFreedom:
        ...
    def getEnergyAccounting(self, heightAtZeroPoint: float = ..., referenceFrameVelocity: numpy.ndarray[numpy.float64[3, 1]] = ..., contactBodies: list[BodyNode] = ..., cops: list[numpy.ndarray[numpy.float64[3, 1]]] = ..., forces: list[numpy.ndarray[numpy.float64[3, 1]]] = ..., moments: list[numpy.ndarray[numpy.float64[3, 1]]] = ...) -> EnergyAccountingFrame:
        ...
    @typing.overload
    def getExternalForces(self, arg0: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getExternalForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGradientOfHeightWrtBodyScales(self, pos: numpy.ndarray[numpy.float64[m, 1]], up: numpy.ndarray[numpy.float64[3, 1]] = ...) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGradientOfLowestPointWrtBodyScales(self, up: numpy.ndarray[numpy.float64[3, 1]] = ...) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGradientOfLowestPointWrtJoints(self, up: numpy.ndarray[numpy.float64[3, 1]] = ...) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGravity(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def getGravityForces(self, arg0: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getGravityForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupCOMLowerBound(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupCOMUpperBound(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupCOMs(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupInertias(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupInertiasLowerBound(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupInertiasUpperBound(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupMasses(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupMassesLowerBound(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupMassesUpperBound(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGroupScaleDim(self) -> int:
        ...
    def getGroupScales(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getGyroMapReadings(self, gyros: dict[str, tuple[BodyNode, _nimblephysics.math.Isometry3]]) -> dict[str, numpy.ndarray[numpy.float64[3, 1]]]:
        """
        These are a set of bodies, and offsets in local body space where gyros
        are mounted on the body
        """
    def getGyroReadings(self, gyros: list[tuple[BodyNode, _nimblephysics.math.Isometry3]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        """
        These are a set of bodies, and offsets in local body space where gyros are mounted on the body.
        """
    def getGyroReadingsJacobianWrt(self, gyros: list[tuple[BodyNode, _nimblephysics.math.Isometry3]], wrt: _nimblephysics.neural.WithRespectTo) -> numpy.ndarray[numpy.float64[m, n]]:
        """
        This returns the Jacobian relating changes in the `wrt` quantity to changes in gyro readings.
        """
    def getHeight(self, pos: numpy.ndarray[numpy.float64[m, 1]], up: numpy.ndarray[numpy.float64[3, 1]] = ...) -> float:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode) -> int:
        ...
    @typing.overload
    def getIndexOf(self, bn: BodyNode, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint) -> int:
        ...
    @typing.overload
    def getIndexOf(self, joint: Joint, warning: bool) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom) -> int:
        ...
    @typing.overload
    def getIndexOf(self, dof: DegreeOfFreedom, warning: bool) -> int:
        ...
    @typing.overload
    def getInvMassMatrix(self, arg0: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def getInvMassMatrix(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getInverseDynamics(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJoint(self, idx: int) -> Joint:
        ...
    @typing.overload
    def getJoint(self, name: str) -> Joint:
        ...
    def getJointWorldPositions(self, joints: list[Joint]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getJointWorldPositionsJacobianWrtBodyScales(self, joints: list[Joint]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getJointWorldPositionsJacobianWrtGroupScales(self, joints: list[Joint]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getJointWorldPositionsJacobianWrtJointPositions(self, joints: list[Joint]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getJointWorldPositionsMap(self) -> dict[str, numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], rotation: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    def getLinearizedMasses(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getLinkMasses(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getLowestPoint(self, up: numpy.ndarray[numpy.float64[3, 1]] = ...) -> float:
        ...
    def getMarkerMapWorldPositions(self, markerMap: dict[str, tuple[BodyNode, numpy.ndarray[numpy.float64[3, 1]]]]) -> dict[str, numpy.ndarray[numpy.float64[3, 1]]]:
        ...
    def getMarkerWorldPositions(self, markers: list[tuple[BodyNode, numpy.ndarray[numpy.float64[3, 1]]]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getMass(self) -> float:
        ...
    @typing.overload
    def getMassMatrix(self, arg0: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def getMassMatrix(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def getMultipleContactInverseDynamics(self, accelerations: numpy.ndarray[numpy.float64[m, 1]], contactBodies: list[BodyNode], bodyWrenchGuesses: list[numpy.ndarray[numpy.float64[6, 1]]] = ...) -> MultipleContactInverseDynamicsResult:
        ...
    def getMultipleContactInverseDynamicsOverTime(self, positions: numpy.ndarray[numpy.float64[m, n]], contactBodies: list[BodyNode], smoothingWeight: float, minTorqueWeight: float, velocityPenalty: typing.Callable[[float], float], prevContactForces: list[numpy.ndarray[numpy.float64[6, 1]]] = ..., prevContactWeight: float = ..., magnitudeCosts: numpy.ndarray[numpy.float64[m, n]] = ...) -> MultipleContactInverseDynamicsOverTimeResult:
        ...
    def getName(self) -> str:
        ...
    def getNumBodyNodes(self) -> int:
        ...
    def getNumDofs(self) -> int:
        ...
    @typing.overload
    def getNumEndEffectors(self) -> int:
        ...
    @typing.overload
    def getNumEndEffectors(self, treeIndex: int) -> int:
        ...
    def getNumJoints(self) -> int:
        ...
    @typing.overload
    def getNumMarkers(self) -> int:
        ...
    @typing.overload
    def getNumMarkers(self, treeIndex: int) -> int:
        ...
    def getNumRigidBodyNodes(self) -> int:
        ...
    @typing.overload
    def getNumShapeNodes(self) -> int:
        ...
    @typing.overload
    def getNumShapeNodes(self, treeIndex: int) -> int:
        ...
    def getNumSoftBodyNodes(self) -> int:
        ...
    def getNumTrees(self) -> int:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getProperties(self) -> ShapeNodeProperties:
        ...
    @typing.overload
    def getPtr(self) -> Skeleton:
        ...
    @typing.overload
    def getPtr(self) -> Skeleton:
        ...
    def getRandomPose(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getRandomPoseForJoints(self, joints: list[Joint]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getRootBodyNode(self) -> BodyNode:
        ...
    @typing.overload
    def getRootBodyNode(self, treeIndex: int) -> BodyNode:
        ...
    @typing.overload
    def getRootJoint(self) -> Joint:
        ...
    @typing.overload
    def getRootJoint(self, treeIndex: int) -> Joint:
        ...
    def getRotationFromMeshToParentBody(self, meshFileName: str, relativeToGeometry: numpy.ndarray[numpy.float64[3, 3]]) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getScaleGroupIndex(self, bodyNode: BodyNode) -> int:
        ...
    def getScaleGroupLowerBound(self, index: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getScaleGroupUpperBound(self, index: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getSelfCollisionCheck(self) -> bool:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    @typing.overload
    def getSkeleton(self) -> Skeleton:
        ...
    @typing.overload
    def getSupportVersion(self) -> int:
        ...
    @typing.overload
    def getSupportVersion(self, treeIdx: int) -> int:
        ...
    def getTimeStep(self) -> float:
        ...
    def getTransformFromMeshToParentBody(self, meshFileName: str, relativeToGeometry: _nimblephysics.math.Isometry3) -> _nimblephysics.math.Isometry3:
        ...
    def getTranslationFromMeshToParentBody(self, meshFileName: str, relativeToGeometry: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getTreeBodyNodes(self, treeIdx: int) -> list[BodyNode]:
        ...
    def getVelocityDifferences(self, dq2: numpy.ndarray[numpy.float64[m, 1]], dq1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getWorldJacobian(self, node: JacobianNode, localOffset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    def hasBodyNode(self, bodyNode: BodyNode) -> bool:
        ...
    def hasJoint(self, joint: Joint) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integratePositionsExplicit(self, pos: numpy.ndarray[numpy.float64[m, 1]], vel: numpy.ndarray[numpy.float64[m, 1]], dt: float) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isEnabledAdjacentBodyCheck(self) -> bool:
        ...
    def isEnabledSelfCollisionCheck(self) -> bool:
        ...
    def isImpulseApplied(self) -> bool:
        ...
    def isMobile(self) -> bool:
        ...
    def mergeScaleGroups(self, bodyNodeA: BodyNode, bodyNodeB: BodyNode) -> None:
        ...
    def mergeScaleGroupsByIndex(self, groupA: int, groupB: int) -> None:
        ...
    def resetUnion(self) -> None:
        ...
    def setAdjacentBodyCheck(self, enable: bool) -> None:
        ...
    def setBodyScales(self, scales: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForcesLowerLimits(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForcesUpperLimits(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setGravity(self, gravity: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setGroupCOMs(self, coms: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setGroupInertias(self, inertias: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setGroupMasses(self, masses: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setGroupScales(self, scales: numpy.ndarray[numpy.float64[m, 1]], silentlyClamp: bool = ...) -> None:
        ...
    def setImpulseApplied(self, val: bool) -> None:
        ...
    def setLinearizedMasses(self, masses: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setLinkMasses(self, masses: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setMobile(self, isMobile: bool) -> None:
        ...
    def setName(self, name: str) -> str:
        ...
    def setPositionLowerLimits(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimits(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: ShapeNodeProperties) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: ShapeNodeProperties) -> None:
        ...
    def setScaleGroupUniformScaling(self, bodyNode: BodyNode, uniform: bool = ...) -> None:
        ...
    def setSelfCollisionCheck(self, enable: bool) -> None:
        ...
    def setTimeStep(self, timeStep: float) -> None:
        ...
    def setVelocityLowerLimits(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimits(self, arg0: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def simplifySkeleton(self, cloneName: str, mergeBodiesInto: dict[str, str]) -> Skeleton:
        ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode: BodyNode) -> None:
        ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode: BodyNode, imp: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def updateBiasImpulse(self, bodyNode1: BodyNode, imp1: numpy.ndarray[numpy.float64[6, 1]], bodyNode2: BodyNode, imp2: numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    def updateVelocityChange(self) -> None:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_EulerJoint_EulerJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_PlanarJoint_PlanarJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_PrismaticJoint_PrismaticJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_RevoluteJoint_RevoluteJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_ScrewJoint_ScrewJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_TranslationalJoint2D_TranslationalJoint2DUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedPropertiesAspect_UniversalJoint_UniversalJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R1_GenericJointState_GenericJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R2_GenericJointState_GenericJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R3_GenericJointState_GenericJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R4_GenericJointState_GenericJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_R6_GenericJointState_GenericJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SE3_GenericJointState_GenericJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SpecializedForAspect_EmbeddedStateAndPropertiesAspect_GenericJoint_SO3_GenericJointState_GenericJointUniqueProperties(_nimblephysics.common.Composite):
    def __init__(self) -> None:
        ...
class SphereShape(Shape):
    @staticmethod
    def computeInertiaOf(radius: float, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def computeVolumeOf(radius: float) -> float:
        ...
    @staticmethod
    def getStaticType() -> str:
        ...
    def __init__(self, radius: float) -> None:
        ...
    def computeInertia(self, mass: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getRadius(self) -> float:
        ...
    def getType(self) -> str:
        ...
    def setRadius(self, radius: float) -> None:
        ...
class TemplatedJacobianBodyNode(JacobianNode):
    @typing.overload
    def getAngularJacobian(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getAngularJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianClassicDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getJacobianSpatialDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    @typing.overload
    def getLinearJacobianDeriv(self, offset: numpy.ndarray[numpy.float64[3, 1]], inCoordinatesOf: Frame) -> numpy.ndarray[numpy.float64[3, n]]:
        ...
    def getWorldJacobian(self, offset: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, n]]:
        ...
class TranslationalJoint(GenericJoint_R3):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[6, 3]]:
        ...
    def getTranslationalJointProperties(self) -> TranslationalJointProperties:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
class TranslationalJoint2D(EmbedPropertiesOnTopOf_TranslationalJoint2D_TranslationalJoint2DUniqueProperties_GenericJoint_R2Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: TranslationalJoint2D) -> None:
        ...
    def getPlaneType(self) -> PlaneType:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[6, 2]]:
        ...
    def getTranslationalAxis1(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getTranslationalAxis2(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getTranslationalJoint2DProperties(self) -> TranslationalJoint2DProperties:
        ...
    def getType(self) -> str:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[numpy.float64[3, 1]], transAxis2: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setArbitraryPlane(self, transAxis1: numpy.ndarray[numpy.float64[3, 1]], transAxis2: numpy.ndarray[numpy.float64[3, 1]], renameDofs: bool) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: TranslationalJoint2DProperties) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: TranslationalJoint2DUniqueProperties) -> None:
        ...
    @typing.overload
    def setXYPlane(self) -> None:
        ...
    @typing.overload
    def setXYPlane(self, renameDofs: bool) -> None:
        ...
    @typing.overload
    def setYZPlane(self) -> None:
        ...
    @typing.overload
    def setYZPlane(self, renameDofs: bool) -> None:
        ...
    @typing.overload
    def setZXPlane(self) -> None:
        ...
    @typing.overload
    def setZXPlane(self, renameDofs: bool) -> None:
        ...
class TranslationalJoint2DProperties(TranslationalJoint2DUniqueProperties):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: TranslationalJoint2DProperties) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: TranslationalJoint2DProperties, uniqueProperties: TranslationalJoint2DUniqueProperties) -> None:
        ...
class TranslationalJoint2DUniqueProperties:
    def __init__(self) -> None:
        ...
class TranslationalJointProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, properties: TranslationalJointProperties) -> None:
        ...
class UniversalJoint(EmbedPropertiesOnTopOf_UniversalJoint_UniversalJointUniqueProperties_GenericJoint_R2Space):
    @staticmethod
    def getStaticType() -> str:
        ...
    def copy(self, otherJoint: UniversalJoint) -> None:
        ...
    def getAxis1(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getAxis2(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRelativeJacobianStatic(self, positions: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[6, 2]]:
        ...
    def getType(self) -> str:
        ...
    def getUniversalJointProperties(self) -> UniversalJointProperties:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setAxis1(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setAxis2(self, axis: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: UniversalJointProperties) -> None:
        ...
    @typing.overload
    def setProperties(self, properties: UniversalJointUniqueProperties) -> None:
        ...
class UniversalJointProperties(UniversalJointUniqueProperties):
    mAxis: list[numpy.ndarray[numpy.float64[3, 1]][2]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: UniversalJointProperties) -> None:
        ...
    @typing.overload
    def __init__(self, genericJointProperties: UniversalJointProperties, uniqueProperties: UniversalJointUniqueProperties) -> None:
        ...
class UniversalJointUniqueProperties:
    def __init__(self) -> None:
        ...
class VisualAspect:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, properties: VisualAspectProperties) -> None:
        ...
    def getAlpha(self) -> float:
        ...
    def getCastShadows(self) -> bool:
        ...
    def getColor(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getHidden(self) -> bool:
        ...
    def getRGB(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def getRGBA(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def getReceiveShadows(self) -> bool:
        ...
    def hide(self) -> None:
        ...
    def isHidden(self) -> bool:
        ...
    def setAlpha(self, alpha: float) -> None:
        ...
    def setCastShadows(self, value: bool) -> None:
        ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def setColor(self, color: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    def setHidden(self, value: bool) -> None:
        ...
    def setRGB(self, rgb: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def setRGBA(self, color: numpy.ndarray[numpy.float64[4, 1]]) -> None:
        ...
    def setReceiveShadows(self, value: bool) -> None:
        ...
    def show(self) -> None:
        ...
class VisualAspectProperties:
    pass
class WeldJoint(ZeroDofJoint):
    @staticmethod
    def getStaticType() -> str:
        ...
    def getType(self) -> str:
        ...
    def getWeldJointProperties(self) -> WeldJointProperties:
        ...
    def isCyclic(self, index: int) -> bool:
        ...
    def setTransformFromChildBodyNode(self, T: _nimblephysics.math.Isometry3) -> None:
        ...
    def setTransformFromParentBodyNode(self, T: _nimblephysics.math.Isometry3) -> None:
        ...
class WeldJointProperties:
    pass
class ZeroDofJoint(Joint):
    def computePotentialEnergy(self) -> float:
        ...
    def getAcceleration(self, index: int) -> float:
        ...
    def getAccelerationLowerLimit(self, index: int) -> float:
        ...
    def getAccelerationLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerationUpperLimit(self, index: int) -> float:
        ...
    def getAccelerationUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getAccelerations(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getBodyConstraintWrench(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def getCommand(self, index: int) -> float:
        ...
    def getCommands(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getConstraintImpulse(self, index: int) -> float:
        ...
    def getControlForce(self, index: int) -> float:
        ...
    def getControlForceLowerLimit(self, index: int) -> float:
        ...
    def getControlForceLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceUpperLimit(self, index: int) -> float:
        ...
    def getControlForceUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForces(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getCoulombFriction(self, index: int) -> float:
        ...
    def getDampingCoefficient(self, index: int) -> float:
        ...
    def getDofName(self, arg0_: int) -> str:
        ...
    def getIndexInSkeleton(self, index: int) -> int:
        ...
    def getIndexInTree(self, index: int) -> int:
        ...
    def getInitialPosition(self, index: int) -> float:
        ...
    def getInitialPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getInitialVelocity(self, index: int) -> float:
        ...
    def getNumDofs(self) -> int:
        ...
    def getPosition(self, index: int) -> float:
        ...
    def getPositionDifferences(self, q2: numpy.ndarray[numpy.float64[m, 1]], q1: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionLowerLimit(self, index: int) -> float:
        ...
    def getPositionLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositionUpperLimit(self, index: int) -> float:
        ...
    def getPositionUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getPositions(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getRestPosition(self, index: int) -> float:
        ...
    def getSpringStiffness(self, index: int) -> float:
        ...
    def getVelocities(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocity(self, index: int) -> float:
        ...
    def getVelocityChange(self, index: int) -> float:
        ...
    def getVelocityLowerLimit(self, index: int) -> float:
        ...
    def getVelocityLowerLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getVelocityUpperLimit(self, index: int) -> float:
        ...
    def getVelocityUpperLimits(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getZeroDofJointProperties(self) -> ZeroDofJointProperties:
        ...
    def hasPositionLimit(self, index: int) -> bool:
        ...
    def integratePositions(self, dt: float) -> None:
        ...
    def integrateVelocities(self, dt: float) -> None:
        ...
    def isDofNamePreserved(self, arg0_: int) -> bool:
        ...
    def preserveDofName(self, arg0_: int, arg1_: bool) -> None:
        ...
    def resetAccelerations(self) -> None:
        ...
    def resetCommands(self) -> None:
        ...
    def resetConstraintImpulses(self) -> None:
        ...
    def resetControlForces(self) -> None:
        ...
    def resetPosition(self, index: int) -> None:
        ...
    def resetPositions(self) -> None:
        ...
    def resetVelocities(self) -> None:
        ...
    def resetVelocity(self, index: int) -> None:
        ...
    def resetVelocityChanges(self) -> None:
        ...
    def setAcceleration(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerationUpperLimit(self, index: int, acceleration: float) -> None:
        ...
    def setAccelerationUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setAccelerations(self, accelerations: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCommand(self, index: int, command: float) -> None:
        ...
    def setCommands(self, commands: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setConstraintImpulse(self, index: int, impulse: float) -> None:
        ...
    def setControlForce(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForceUpperLimit(self, index: int, force: float) -> None:
        ...
    def setControlForceUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setControlForces(self, forces: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setCoulombFriction(self, index: int, friction: float) -> None:
        ...
    def setDampingCoefficient(self, index: int, d: float) -> None:
        ...
    def setDofName(self, arg0_: int, arg1_: str, arg2_: bool) -> str:
        ...
    def setInitialPosition(self, index: int, initial: float) -> None:
        ...
    def setInitialPositions(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocities(self, initial: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setInitialVelocity(self, index: int, initial: float) -> None:
        ...
    def setPosition(self, arg0_: int, arg1_: float) -> None:
        ...
    def setPositionLowerLimit(self, index: int, position: float) -> None:
        ...
    def setPositionLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositionUpperLimit(self, index: int, position: float) -> None:
        ...
    def setPositionUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setPositions(self, positions: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setRestPosition(self, index: int, q0: float) -> None:
        ...
    def setSpringStiffness(self, index: int, k: float) -> None:
        ...
    def setVelocities(self, velocities: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocity(self, index: int, velocity: float) -> None:
        ...
    def setVelocityChange(self, index: int, velocityChange: float) -> None:
        ...
    def setVelocityLowerLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityLowerLimits(self, lowerLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def setVelocityUpperLimit(self, index: int, velocity: float) -> None:
        ...
    def setVelocityUpperLimits(self, upperLimits: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class ZeroDofJointProperties:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, properties: JointProperties) -> None:
        ...
