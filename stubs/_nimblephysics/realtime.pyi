"""
This provides a native realtime MPC and SSID framework to DART, utilizing the trajectory package to solve.
"""
from __future__ import annotations
import _nimblephysics.simulation
import _nimblephysics.trajectory
import numpy
import typing
__all__ = ['MPC', 'MPCLocal', 'MPCRemote', 'Ticker']
class MPC:
    def getControlForce(self, now: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getControlForceNow(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getRemainingPlanBufferMillis(self) -> int:
        ...
    def recordGroundTruthState(self, time: int, pos: numpy.ndarray[numpy.float64[m, 1]], vel: numpy.ndarray[numpy.float64[m, 1]], mass: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def recordGroundTruthStateNow(self, pos: numpy.ndarray[numpy.float64[m, 1]], vel: numpy.ndarray[numpy.float64[m, 1]], mass: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def registerReplaningListener(self, replanListener: typing.Callable[[int, _nimblephysics.trajectory.TrajectoryRollout, int], None]) -> None:
        ...
    def start(self) -> None:
        ...
    def stop(self) -> None:
        ...
class MPCLocal(MPC):
    def __init__(self, world: _nimblephysics.simulation.World, loss: _nimblephysics.trajectory.LossFn, planningHorizonMillis: int) -> None:
        ...
    def adjustPerformance(self, lastOptimizationTimeMillis: int) -> None:
        ...
    def getCurrentSolution(self) -> _nimblephysics.trajectory.Solution:
        ...
    def getMaxIterations(self) -> int:
        ...
    def getOptimizer(self) -> _nimblephysics.trajectory.Optimizer:
        ...
    def getProblem(self) -> _nimblephysics.trajectory.Problem:
        ...
    def getRemainingPlanBufferMillis(self) -> int:
        ...
    def optimizePlan(self, now: int) -> None:
        ...
    def recordGroundTruthState(self, time: int, pos: numpy.ndarray[numpy.float64[m, 1]], vel: numpy.ndarray[numpy.float64[m, 1]], mass: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def recordGroundTruthStateNow(self, pos: numpy.ndarray[numpy.float64[m, 1]], vel: numpy.ndarray[numpy.float64[m, 1]], mass: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def registerReplaningListener(self, replanListener: typing.Callable[[int, _nimblephysics.trajectory.TrajectoryRollout, int], None]) -> None:
        ...
    def serve(self, port: int) -> None:
        """
        A blocking call - this starts a gRPC server that clients can connect to to get MPC computations done remotely
        """
    def setEnableLineSearch(self, enabled: bool) -> None:
        ...
    def setEnableOptimizationGuards(self, enabled: bool) -> None:
        ...
    def setLoss(self, loss: _nimblephysics.trajectory.LossFn) -> None:
        ...
    def setMaxIterations(self, maxIterations: int) -> None:
        ...
    def setOptimizer(self, optimizer: _nimblephysics.trajectory.Optimizer) -> None:
        ...
    def setProblem(self, problem: _nimblephysics.trajectory.Problem) -> None:
        ...
    def setRecordIterations(self, enabled: bool) -> None:
        ...
    def setSilent(self, silent: bool) -> None:
        ...
    def start(self) -> None:
        ...
    def stop(self) -> None:
        ...
class MPCRemote(MPC):
    @typing.overload
    def __init__(self, host: str, port: int, dofs: int, steps: int, millisPerStep: int) -> None:
        ...
    @typing.overload
    def __init__(self, local: MPCLocal, ignored: int = ...) -> None:
        ...
    def getControlForce(self, now: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getRemainingPlanBufferMillis(self) -> int:
        ...
    def recordGroundTruthState(self, time: int, pos: numpy.ndarray[numpy.float64[m, 1]], vel: numpy.ndarray[numpy.float64[m, 1]], mass: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def recordGroundTruthStateNow(self, pos: numpy.ndarray[numpy.float64[m, 1]], vel: numpy.ndarray[numpy.float64[m, 1]], mass: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def registerReplaningListener(self, replanListener: typing.Callable[[int, _nimblephysics.trajectory.TrajectoryRollout, int], None]) -> None:
        ...
    def start(self) -> None:
        ...
    def stop(self) -> None:
        ...
class Ticker:
    def __init__(self, secondsPerTick: float) -> None:
        ...
    def clear(self) -> None:
        ...
    def registerTickListener(self, listener: typing.Callable[[int], None]) -> None:
        ...
    def start(self) -> None:
        ...
    def stop(self) -> None:
        ...
